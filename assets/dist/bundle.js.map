{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAqC;AACN;AACxB,qBAAqB,6CAAG,IAAI,qGAAqG;AACxI,WAAW,8CAAI;AACf,MAAM,2BAA2B,8CAAI,IAAI,4CAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE,QAAQ,mBAAmB;AAClC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;AC/BqC;AACN;AACxB,mBAAmB,6CAAG,IAAI;AACjC;AACA,kFAAkF;AAClF,WAAW,8CAAI;AACf,6BAA6B;AAC7B,kCAAkC,gBAAgB,iBAAiB;AACnE;AACA,UAAU,gBAAgB,8CAAI;AAC9B,yCAAyC,OAAO,iBAAiB;AACjE;AACA,gBAAgB,uBAAuB,8CAAI;AAC3C;AACA,iCAAiC;AACjC,4BAA4B;AAC5B,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB,8CAAI;AACjC;AACA,gBAAgB,wBAAwB,8CAAI;AAC5C;AACA,oBAAoB,4CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;AC5CwD;AACF;AACF;AACF;AAC3C,sBAAsB,6CAAG,IAAI,+EAA+E;AACnH;AACA,sBAAsB,kDAAQ;AAC9B,2BAA2B,kDAAQ;AACnC,mBAAmB,+CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6CAA6C,iEAAU;AACvD;AACA;AACA;AACA,KAAK,IAAI,+DAAY;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,8CAAI;AACf,MAAM;;AAEN,iBAAiB,UAAU;AAC3B,wDAAwD;AACxD,0BAA0B,QAAQ,GAAG,sCAAsC,wBAAwB,SAAS,YAAY,oCAAoC,mCAAmC,yDAAyD,wBAAwB;AAChR,qBAAqB,SAAS,EAAE,4CAA4C,yBAAyB,kCAAkC,kCAAkC,8BAA8B,0BAA0B;AACjO,wBAAwB,MAAM,EAAE,4BAA4B,sBAAsB,iCAAiC,iCAAiC,yDAAyD;AAC7M,gBAAgB;AAChB;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB,YAAY;AAC/D;AACA;AACA;AACA,UAAU;AACV;AACA,eAAe,8CAAI;AACnB;AACA,kCAAkC,+BAA+B;AACjE;AACA;AACA,gBAAgB,qEAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;ACrEsD;AAC/C,qBAAqB,6CAAG,IAAI,oDAAoD;AACvF,4BAA4B,kDAAQ;AACpC,eAAe,kDAAQ;AACvB,sBAAsB,kDAAQ;AAC9B,qBAAqB,+CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D,SAAS;AACT;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA,WAAW,8CAAI;AACf,iBAAiB,aAAa,sBAAsB;AACpD,+BAA+B,uBAAuB,QAAQ,EAAE;AAChE;;AAEA;AACA,oBAAoB;AACpB,mBAAmB;AACnB;AACA,4BAA4B;AAC5B,kBAAkB;AAClB,eAAe;AACf;AACA,QAAQ,2DAA2D,8CAAI;AACvE,6BAA6B,YAAY,MAAM;AAC/C,UAAU,8CAAI;AACd,6BAA6B,YAAY,OAAO;AAChD;AACA;;AAEA,MAAM,QAAQ,8CAAI;AAClB,6BAA6B,cAAc;AAC3C,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA,YAAY,eAAe,8CAAI;AAC/B,sCAAsC;AACtC;AACA;AACA;AACA,yBAAyB;AACzB,eAAe,kBAAkB;AACjC;AACA,mCAAmC,eAAe;AAClD,cAAc,wBAAwB,8CAAI;AAC1C;AACA;AACA,8BAA8B,cAAc;AAC5C,iCAAiC,4BAA4B;AAC7D;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA,CAAC;AACD,mDAAmD;AACnD,wCAAwC,uCAAuC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C,2CAA2C,qBAAqB;AAChE;AACA;AACA;;;;;;;;;;;;;;;;ACvGqC;AACU;AACxC,qBAAqB,6CAAG,IAAI,sDAAsD;AACzF,WAAW,8CAAI;AACf;AACA;AACA,8CAA8C;AAC9C;;AAEA,yBAAyB;AACzB;AACA,8CAA8C;AAC9C,+CAA+C;AAC/C,kDAAkD;AAClD,+BAA+B;AAC/B,mCAAmC;AACnC;AACA,4BAA4B,iBAAiB;AAC7C,oCAAoC;AACpC,iCAAiC,cAAc,kBAAkB,UAAU;AAC3E,YAAY,gCAAgC,8CAAI;AAChD;AACA,sBAAsB,YAAY,kBAAkB,YAAY,mBAAmB,aAAa,mBAAmB,oBAAoB;AACvI,6CAA6C;AAC7C;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,oBAAoB,YAAY,kBAAkB,YAAY,mBAAmB,aAAa,mBAAmB,oBAAoB;AACrI,kEAAkE;AAClE;AACA,sBAAsB;AACtB;AACA,qBAAqB,YAAY,kBAAkB,YAAY,mBAAmB,aAAa,mBAAmB,oBAAoB;AACtI,uDAAuD;AACvD;AACA,sBAAsB;AACtB;AACA,+BAA+B,kBAAkB,YAAY,mBAAmB,aAAa,mBAAmB,oBAAoB;AACpI;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,IAAI,4DAAQ;AACZ;AACA;;;;;;;;;;;;;;ACrDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACTgE;AACpB;AACE;AACA;AACI;AAC3C,aAAa,6CAAG,IAAI;AAC3B,mKAAmK;AACnK;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAQ;AACvB,IAAI,iDAAO;AACX,IAAI,iDAAO;AACX,oBAAoB,kDAAQ;AAC5B,IAAI,gDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,8CAAI;AAC3B;AACA,mBAAmB,2DAAU;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe,8CAAI;AACnB;AACA,UAAU,cAAc,+DAAY;AACpC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,UAAU,sBAAsB,8CAAI;AACpC,mEAAmE,YAAY,iBAAiB,YAAY;AAC5G,aAAa,+BAA+B;AAC5C,2BAA2B,yDAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY,2DAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAU;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,2DAAU,GAAG,gCAAgC;AAC5D;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;AC3F0D;AACJ;AAC/C,kBAAkB,6CAAG,IAAI;AAChC;AACA;AACA,0CAA0C;AAC1C,oBAAoB,kDAAQ;AAC5B,oBAAoB,kDAAQ;AAC5B,IAAI,+CAAK;AACT,WAAW,8CAAI;AACf;AACA,yBAAyB,yBAAyB,uBAAuB,kBAAkB,uBAAuB;AAClH;AACA;AACA,cAAc,eAAe,aAAa,8BAA8B,YAAY,cAAc,mBAAmB,YAAY,yBAAyB;AAC1J,8CAA8C,0BAA0B,mBAAmB;AAC3F;AACA,uCAAuC;AACvC;AACA,MAAM;AACN,kBAAkB,IAAI;AACtB;AACA,8BAA8B,cAAc;AAC5C,4CAA4C,sBAAsB;AAClE,oBAAoB,8DAA8D,GAAG,yCAAyC;AAC9H;AACA,8BAA8B,cAAc,uBAAuB,aAAa;AAChF,QAAQ;AACR;AACA;AACA,MAAM,oFAAoF,8CAAI;AAC9F;AACA,kCAAkC,aAAa,eAAe,aAAa;AAC3E,UAAU,uEAAa;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;AC7C6D;AAC9B;AACxB,mBAAmB,6CAAG,IAAI;AACjC,8FAA8F;AAC9F,oBAAoB,kDAAQ;AAC5B,mBAAmB,kDAAQ;AAC3B,uBAAuB,+CAAK;AAC5B,IAAI,+CAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAAI;AACf,+BAA+B,gBAAgB;AAC/C;AACA,6BAA6B,cAAc,yBAAyB,uBAAuB,kBAAkB,uBAAuB,aAAa;AACjJ;AACA,UAAU,OAAO,8CAAI;AACrB,uBAAuB,eAAe,aAAa,8BAA8B,cAAc,YAAY,mBAAmB,YAAY,yBAAyB;AACnK,8CAA8C,0BAA0B,mBAAmB;AAC3F;AACA,yBAAyB,6BAA6B;AACtD,wBAAwB,IAAI;AAC5B,sCAAsC,cAAc;AACpD,iBAAiB,EAAE;AACnB;AACA;AACA,cAAc,iBAAiB,8CAAI;AACnC,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA,UAAU,gBAAgB,8CAAI;AAC9B,mCAAmC;AACnC,cAAc,4CAA4C,8CAAI;AAC9D;AACA;AACA,wBAAwB,eAAe,cAAc,aAAa,eAAe;AACjF,iEAAiE,iBAAiB;AAClF;AACA,kBAAkB,4CAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,qBAAqB,YAAY;AACjC,4DAA4D;AAC5D,8BAA8B,QAAQ,GAAG,sCAAsC,wBAAwB,SAAS,YAAY,oCAAoC,mCAAmC,yDAAyD,wBAAwB;AACpR,yBAAyB,SAAS,EAAE,4CAA4C,yBAAyB,kCAAkC,kCAAkC,8BAA8B,0BAA0B;AACrO,4BAA4B,MAAM,EAAE,4BAA4B,sBAAsB,iCAAiC,iCAAiC,yDAAyD;AACjN;AACA;AACA;AACA;AACA,YAAY,YAAY,8CAAI;AAC5B;AACA;;AAEA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACnF+C;AACA;AACxC,sBAAsB,2BAA2B;AACxD;AACA,WAAW,8CAAI;AACf,8BAA8B,cAAc;AAC5C,QAAQ,OAAO,8CAAI;AACnB,4CAA4C,0BAA0B,mBAAmB,cAAc,mBAAmB,iBAAiB,iBAAiB;AAC5J,yBAAyB;AACzB,oBAAoB;AACpB,WAAW,IAAI;AACf;AACA,QAAQ;AACR;AACA;AACA;AACA,oBAAoB,6CAAG;AACvB;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,QAAQ,4DAAQ,SAAS;AACzB;AACA,WAAW,8CAAI;AACf;AACA,oBAAoB;AACpB,kBAAkB;AAClB,4BAA4B;AAC5B,+BAA+B;AAC/B,sBAAsB;AACtB;AACA;AACA,cAAc;AACd,OAAO,sGAAsG;AAC7G;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAAI;AACf,iBAAiB,MAAM,4DAAQ,SAAS,OAAO;AAC/C;AACA;AACA;AACA,OAAO,MAAM;AACb;AACA;AACA;;;;;;;;;;;;;;;AC9DkC;AAClC;;;;;;;;;;;;;;ACDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvaU;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAqC;AACR;AACsC;AACF;AACN;AACR;AACI;AACd;AACgB;AAC5D;AACA;AACP;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oBAAoB;AACpB;AACA,oCAAoC;AACpC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gFAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,4BAA4B;AAChG;AACA,aAAa;AACb;AACA;AACA,yEAAyE,4BAA4B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA,KAAK;AACL;AACA,0GAA0G;AAC1G,gCAAgC;AAChC;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,EAAE,eAAe,EAAE,OAAO;AACrG;AACA;AACA;AACA,SAAS;AACT,8BAA8B,sEAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,eAAe,gEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0EAAe;AACnD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,SAAS;AACT;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,gBAAgB;AAC9F;AACA,gBAAgB,gBAAgB,EAAE,uEAAkB;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAmB,2FAA2F,gBAAgB;AAC1I;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAW;AAC9B;AACA;AACA;AACA,4BAA4B,mEAAa;AACzC;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAc;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzT4C;AAC6B;AAClE;AACP;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAA+E;AACrG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kDAAkD;AAClD,4CAA4C;AAC5C,6BAA6B,yDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa,0DAAa;AAC1B,4CAA4C,yDAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAa;AACzB;AACA;AACA,YAAY,2DAAc;AAC1B;AACA,mBAAmB,yDAAS;AAC5B;AACA,YAAY,uDAAU;AACtB;AACA;AACA,eAAe,yDAAS;AACxB,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9D+E;AAC9C;AACkB;AACM;AAClD;AACP;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,mBAAmB,+EAA+E;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAe;AACvB;AACA;AACA;AACA,QAAQ,2DAAe;AACvB;AACA,0BAA0B,0CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAc;AAClB,sCAAsC,gEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sEAAgB;AACpB;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3E6C;AACkB;AAC/D;AACO;AACP;AACA;AACA;AACA,sBAAsB,0DAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,IAAI,4EAAgB;AACpB;AACA;;;;;;;;;;;;;;;;;ACzCA;AAC+D;AACxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,aAAa;AACb;AACA,+BAA+B;AAC/B;AACA,IAAI,4EAAgB;AACpB;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,YAAY,4EAAgB;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACvCyE;AACtB;AAC6B;AAC3B;AAC9C;AACP;AACA;AACA;AACA;AACA,qBAAqB,uDAAU;AAC/B;AACA;AACA;AACA,QAAQ,kEAAW;AACnB,4BAA4B,KAAK,4BAA4B,sBAAsB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAa;AACxC,6BAA6B,0DAAa;AAC1C;AACA;AACA;AACA,iBAAiB,gEAAU;AAC3B;AACA;AACA,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA;AACA,oCAAoC,2DAAc;AAClD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,2EAAqB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,kEAAW;AACnB;AACA;;;;;;;;;;;;;;;;AC5EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpGO;AACP;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;ACbO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;;;;;;;;;;;;;;;;;AChBO;AACP;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzB4C;AACrC;AACP,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,qCAAqC;AACrC,yCAAyC;AACzC;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB,yDAAS;AAC7B,gCAAgC;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACpEkC;AAC3B;AACP,eAAe,2CAAG;AAClB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA,YAAY,YAAY;AACkB;AACK;AACzB;AACC;AACE;AACO;AACH;AACC;AACK;AACnC;AACqC;AACrC;AAC0C;AACR;AACY;AACiB;AACxD;AACP,cAAc;AACd;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjBA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACJ+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4EAAgB;AACxB,sCAAsC;AACtC,KAAK;AACL;;;;;;;;;;;;;;;;AClB4D;AACrD;AACP;AACA,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC,EAAE,yEAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe,EAAE,yEAAmB;AAChE;AACA;AACA;AACA;AACA,wBAAwB,sDAAsD;AAC9E;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxCgE;AACN;AACkB;AACjB;AAC3D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD,EAAE,yFAA2B;AACpG;AACA;AACA;AACA,IAAI,6EAAqB;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,6EAAqB;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,mBAAmB,uEAAsB;AACzC,0CAA0C,oDAAY,EAAE,sDAAc;AACtE;AACA;;;;;;;;;;;;;;;;;;;;;;;AClC6C;AACS;AACe;AACX;AACO;AACI;AAC9D;AACP,+BAA+B,WAAW,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,mCAAmC,sDAAc,aAAa,sDAAc;AAC5E,iBAAiB,UAAU;AAC3B;AACA;AACA,sBAAsB,2DAAc,2BAA2B,uDAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,gBAAgB;AAC3F,aAAa;AACb;AACO;AACP,EAAE,gBAAgB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA;AACA,QAAQ,kFAAmB;AAC3B,sBAAsB,WAAW;AACjC;AACA,SAAS;AACT;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC;AAClC;AACA,QAAQ,8EAAiB;AACzB;AACA;AACA,WAAW,mEAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACvFA;AACO,sGAAsG,WAAW,GAAG;AAC3H,eAAe,GAAG;AACX;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD,KAAK;AACL,aAAa;AACb;;;;;;;;;;;;;;;;;;AChBO;AACP;AACA;AACO;AACP;AACA;AACO;AACP,+EAA+E;AAC/E;AACO;AACP;AACA;;;;;;;;;;;;;;;ACXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5BkD;AACD;AACoB;AACrE,wBAAwB;AACxB,kBAAkB;AAClB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAc;AAC7B;AACA;AACA,yDAAyD;AACzD;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA,+BAA+B,kFAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxHsD;AAC0B;AACzE;AACP,QAAQ,2DAAc;AACtB,+BAA+B,+DAAY;AAC3C;AACA;AACA;AACA;AACA,mBAAmB,+DAAY;AAC/B;AACA;AACA,gBAAgB;AAChB;AACA,QAAQ,0DAAa;AACrB;AACA,mBAAmB,+DAAY;AAC/B;AACA,QAAQ,8DAAiB;AACzB,sBAAsB;AACtB;AACA,eAAe,+DAAY;AAC3B;;;;;;;;;;;;;;;;ACtBuE;AAChE;AACP;AACA;AACA,kDAAkD;AAClD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB,oFAAoB;AACtC,2BAA2B;AAC3B;;;;;;;;;;;;;;;;;;;ACb4D;AAC3B;AAC8B;AACf;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uIAAuI,MAAM;AAC7I;AACA;AACA,+BAA+B,yDAAU;AACzC;AACA;AACA,sBAAsB,0CAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,IAAI,4EAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1C6E;AACJ;AACrB;AACiB;AAClB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA,QAAQ,2DAAc;AACtB;AACA;AACA,QAAQ,0DAAa;AACrB;AACA;AACA,QAAQ,uDAAU;AAClB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA;AACA,mBAAmB,iEAAe;AAClC;AACA,YAAY,0FAAuB;AACnC;AACA;AACA,IAAI,kFAAmB;AACvB;;;;;;;;;;;;;;;;;;ACxCgD;AACP;AACzC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA,KAAK;AACL;AACO;AACP;AACA,yBAAyB,yDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,+BAA+B;AAC/B,SAAS;AACT,sBAAsB,kDAAY;AAClC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;;;;;;;;;;;;;;;;;;AC5CsD;AACX;AACuB;AACP;AACpD;AACP;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC,+DAAY,GAAG;AAC/C,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4CAA4C;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjHO;AACP;AACA,EAAE,uBAAuB;AACzB;AACA;AACA;AACA,sFAAsF;AACtF,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACf8D;AACF;AACT;AACnD;AACO;AACP;AACA;AACA;AACA;AACA,IAAI,2EAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG;AACjG,mBAAmB,yEAAiB;AACpC;AACA;AACA,QAAQ,gEAAU;AAClB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1B4C;AACC;AACoB;AACjE;AACO;AACP;AACA,QAAQ,0DAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAS;AACvC;AACA;AACA,qDAAqD;AACrD,gBAAgB,8EAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrC+D;AAC/D,0EAA0E,IAAI;AACvE;AACP;AACA;AACA,+CAA+C,IAAI;AACnD;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,QAAQ,4EAAgB;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;ACd2C;AACG;AACkB;AAClB;AAC9C;AACA,cAAc,sDAAiB;AAC/B;AACO;AACP,sCAAsC;AACtC,wDAAM;AACN;AACA;AACA;AACA,wCAAwC;AACxC,KAAK;AACL,CAAC;AACD;AACA;AACA,0BAA0B,2DAAa;AACvC;AACA;AACA,iCAAiC;AACjC;AACA,8CAA8C;AAC9C,KAAK;AACL;AACA;AACA,qBAAqB,oDAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4EAAgB;AACpB;AACA;AACA;AACA;AACA,YAAY,4EAAgB;AAC5B,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDiC;AACU;AACF;AACM;AACF;AACL;AACC;AAChB;AACG;;;;;;;;;;;;;;;;;ACRkB;AACH;AAC3C;AACO;AACP,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxC2C;AAC3C;AACA;AACO;AACP;AACA;AACA,wDAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACf0C;AAC3C;AACA,IAAI,oDAAM;AACV;AACO;AACP,sBAAsB,oDAAM;AAC5B;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,wDAAM;AACN;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;ACfuD;AACQ;AACzD;AACP;AACA,sEAAsE,yDAAS;AAC/E;AACA;AACA;AACA;AACA,yBAAyB,yDAAS;AAClC,KAAK;AACL;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA,oBAAoB;AACpB;AACA;AACA;AACA,6BAA6B,yDAAS;AACtC,YAAY,4EAAgB;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtC6C;AACF;AAC3C;AACA,oDAAM;AACN;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAM;AACzB;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6BAA6B,yDAAS;AACtC;AACA;AACA;AACA;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA,mBAAmB,yDAAS;AAC5B,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,eAAe,uCAAuC;AACtD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,yDAAS,qBAAqB;AAC/D;AACA;AACA;AACA,oCAAoC;AACpC;AACA,kDAAkD,kBAAkB,EAAE,YAAY;AAClF,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,wDAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA,CAAC;AACD;AACA,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpF8C;AACH;AAC3C;AACO;AACP,mBAAmB,oDAAM;AACzB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZ2C;AACG;AAC9C;AACO;AACP,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA,uBAAuB,2DAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChC+C;AACJ;AAC3C;AACA,oDAAM;AACN;AACA;AACA;AACA;AACA,wDAAM;AACN;AACA;AACA;AACA;AACA,uBAAuB,oDAAM;AAC7B;AACA;AACA;AACA,8DAA8D,gBAAgB,MAAM,oBAAoB;AACxG;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAkB;AACpD;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qCAAqC;AACrC,4EAA4E;AAC5E;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAiD;AAClF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kBAAkB,uDAAkB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpF+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,4DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;;;;;;;;;;;;;;;ACrH0C;AACnC,2BAA2B,mDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACb0C;AACnC;AACP,uBAAuB,mDAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtBgC;AACD;AACU;AACR;;;;;;;;;;;;;;;;;ACH1B;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;AC9B4E;AAC3C;AACyB;AACM;AACpB;AACI;AACG;AACG;AAC/C;AACP;AACA;AACA;AACO;AACP;AACA,0BAA0B,0DAAa,WAAW,uDAAU;AAC5D;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,8BAA8B,mEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB,iBAAiB;AACjB;AACA;AACA,QAAQ,uDAAU;AAClB,iBAAiB,kBAAkB,+DAAY;AAC/C;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB,+DAAY;AAC/C;AACA;AACA,0BAA0B,+DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0CAAM;AAChC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAU;AACpC,4BAA4B,yDAAS,SAAS;AAC9C;AACA;AACA;AACA,6BAA6B,yDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,wBAAwB,6EAAc;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChHoD;AACU;AACR;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA,mEAAmE,kBAAkB;AACrF;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,aAAa;AACb;AACO;AACP,wBAAwB,+DAAY,GAAG;AACvC,2BAA2B,6DAAc;AACzC;AACA,IAAI,2DAAe;AACnB;AACA;AACA;AACA;AACA,IAAI,0DAAc;AAClB,aAAa;AACb;;;;;;;;;;;;;;;;;;;;;AC3CA,wDAAwD;AACvB;AACG;AACpC;AACO,uBAAuB,6CAAO;AACrC,SAAS,0CAAM;AACf,6BAA6B;AAC7B;AACA,CAAC;AACD;AACO;AACP,IAAI,0CAAM;AACV;AACA;AACO;AACP,IAAI,0CAAM;AACV;AACA;AACA;AACO;AACP,IAAI,0CAAM;AACV;AACA;AACO;AACP,IAAI,0CAAM;AACV;;;;;;;;;;;;;;;ACzBA;AACO;AACP;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACduE;AACM;AACpB;AACM;AACL;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,eAAe,0FAAuB;AACtC;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,SAAS;AACT;AACA;AACA;AACA,2BAA2B,oFAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,+CAA+C;AAC/C;AACA,mBAAmB,4EAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAgB;AAC5B,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,uEAAiB;AACpC;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;AChIgD;AAC4C;AACxC;AAC+B;AACd;AACE;AACM;AAC1B;AACkB;AACE;AAChE;AACP;AACA,wBAAwB,2DAAc;AACtC,IAAI,oFAAoB;AACxB;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAuB;AACnC;AACA;AACA,0BAA0B,sBAAsB;AAChD,aAAa;AACb;AACA;AACA,mCAAmC,yDAAU;AAC7C;AACA;AACA,QAAQ,gGAA0B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAU;AAClB,QAAQ,iEAAe;AACvB,oBAAoB;AACpB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAmB;AACzC;AACA;AACA;AACA,QAAQ,0DAAa;AACrB,QAAQ,gEAAU;AAClB;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA,IAAI,kFAAmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAU;AACzC;AACA;AACA;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAU;AACzB;AACA,WAAW,kFAAmB;AAC9B;;;;;;;SCzFA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;;;;;;;ACN+C;AACV;AACK;AACJ;AAC/B,aAAa,6CAAG;AACvB,yBAAyB,kDAAQ;AACjC;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G;AAC3G;AACA;AACA;AACA;AACA;AACA,WAAW,8CAAI;AACf;AACA;AACA;;AAEA,MAAM,WAAW,8CAAI;AACrB,8BAA8B,qBAAqB,aAAa;AAChE;AACA;AACA;AACA,6BAA6B,eAAe,kBAAkB,wBAAwB,SAAS,aAAa;AAC5G;AACA,mBAAmB;AACnB,+BAA+B,iBAAiB;AAChD,SAAS,sCAAsC;;AAE/C,QAAQ,uBAAuB,8CAAI;AACnC,2BAA2B,gBAAgB,WAAW,gBAAgB,sCAAsC;AAC5G,YAAY,mDAAI;AAChB;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,6BAA6B,eAAe,kBAAkB,wBAAwB,QAAQ;AAC9F;AACA,UAAU,mDAAI;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,gBAAgB;AAChD,iBAAiB;AACjB;AACA,gCAAgC,gBAAgB;AAChD,iBAAiB;AACjB;AACA,gCAAgC,gBAAgB;AAChD,iBAAiB;AACjB;AACA,KAAK;AACL;AACA,UAAU,mDAAI;AACd,eAAe,mDAAU;AACzB,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C,2CAA2C,qBAAqB;AAChE;AACA","sources":["webpack:///./node_modules/taggedjs-dump/js/arrayDisplay.tag.js","webpack:///./node_modules/taggedjs-dump/js/arrayTable.component.js","webpack:///./node_modules/taggedjs-dump/js/arraysDisplay.component.js","webpack:///./node_modules/taggedjs-dump/js/columnEditor.component.js","webpack:///./node_modules/taggedjs-dump/js/controlPanel.tag.js","webpack:///./node_modules/taggedjs-dump/js/copyText.function.js","webpack:///./node_modules/taggedjs-dump/js/dump.tag.js","webpack:///./node_modules/taggedjs-dump/js/dumpArray.tag.js","webpack:///./node_modules/taggedjs-dump/js/dumpObject.tag.js","webpack:///./node_modules/taggedjs-dump/js/dumpSimple.tag.js","webpack:///./node_modules/taggedjs-dump/js/index.js","webpack:///./src/sampleData.ts","webpack:///../../taggedjs/main/ts/ElementTargetEvent.interface.ts","webpack:///../../taggedjs/main/ts/Tag.class.ts","webpack:///../../taggedjs/main/ts/TagSupport.class.ts","webpack:///../../taggedjs/main/ts/TemplaterResult.class.ts","webpack:///../../taggedjs/main/ts/alterProps.function.ts","webpack:///../../taggedjs/main/ts/bindSubjectCallback.function.ts","webpack:///../../taggedjs/main/ts/checkDestroyPrevious.function.ts","webpack:///../../taggedjs/main/ts/deepFunctions.ts","webpack:///../../taggedjs/main/ts/destroyTag.function.ts","webpack:///../../taggedjs/main/ts/elementDestroyCheck.function.ts","webpack:///../../taggedjs/main/ts/elementInitCheck.ts","webpack:///../../taggedjs/main/ts/errors.ts","webpack:///../../taggedjs/main/ts/hasTagSupportChanged.function.ts","webpack:///../../taggedjs/main/ts/html.ts","webpack:///../../taggedjs/main/ts/index.ts","webpack:///../../taggedjs/main/ts/inputAttribute.ts","webpack:///../../taggedjs/main/ts/insertAfter.function.ts","webpack:///../../taggedjs/main/ts/interpolateAttributes.ts","webpack:///../../taggedjs/main/ts/interpolateContentTemplates.ts","webpack:///../../taggedjs/main/ts/interpolateElement.ts","webpack:///../../taggedjs/main/ts/interpolateTemplate.ts","webpack:///../../taggedjs/main/ts/interpolations.ts","webpack:///../../taggedjs/main/ts/isInstance.ts","webpack:///../../taggedjs/main/ts/isLikeTags.function.ts","webpack:///../../taggedjs/main/ts/processAttribute.function.ts","webpack:///../../taggedjs/main/ts/processNewValue.function.ts","webpack:///../../taggedjs/main/ts/processRegularValue.function.ts","webpack:///../../taggedjs/main/ts/processSubjectComponent.function.ts","webpack:///../../taggedjs/main/ts/processSubjectValue.function.ts","webpack:///../../taggedjs/main/ts/processTag.function.ts","webpack:///../../taggedjs/main/ts/processTagArray.ts","webpack:///../../taggedjs/main/ts/processTagResult.function.ts","webpack:///../../taggedjs/main/ts/render.ts","webpack:///../../taggedjs/main/ts/renderExistingTag.function.ts","webpack:///../../taggedjs/main/ts/renderTagSupport.function.ts","webpack:///../../taggedjs/main/ts/scanTextAreaValue.function.ts","webpack:///../../taggedjs/main/ts/state/callbackMaker.function.ts","webpack:///../../taggedjs/main/ts/state/index.ts","webpack:///../../taggedjs/main/ts/state/letState.function.ts","webpack:///../../taggedjs/main/ts/state/onDestroy.ts","webpack:///../../taggedjs/main/ts/state/onInit.ts","webpack:///../../taggedjs/main/ts/state/provider.utils.ts","webpack:///../../taggedjs/main/ts/state/providers.ts","webpack:///../../taggedjs/main/ts/state/setProp.function.ts","webpack:///../../taggedjs/main/ts/state/setUse.function.ts","webpack:///../../taggedjs/main/ts/state/state.function.ts","webpack:///../../taggedjs/main/ts/state/state.utils.ts","webpack:///../../taggedjs/main/ts/state/watch.function.ts","webpack:///../../taggedjs/main/ts/subject/Subject.class.ts","webpack:///../../taggedjs/main/ts/subject/ValueSubject.ts","webpack:///../../taggedjs/main/ts/subject/combineLatest.function.ts","webpack:///../../taggedjs/main/ts/subject/index.ts","webpack:///../../taggedjs/main/ts/subject/will.functions.ts","webpack:///../../taggedjs/main/ts/tag.ts","webpack:///../../taggedjs/main/ts/tagElement.ts","webpack:///../../taggedjs/main/ts/tagRunner.ts","webpack:///../../taggedjs/main/ts/updateBeforeTemplate.function.ts","webpack:///../../taggedjs/main/ts/updateExistingTagComponent.function.ts","webpack:///../../taggedjs/main/ts/updateExistingValue.function.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/index.ts"],"sourcesContent":["import { html, tag } from \"taggedjs\";\nimport { dump } from \"./index\";\nexport const arrayDisplay = tag(({ array, showLevels, showAll, showKids, columnNames, formatChange, toggleColumnDialog, allowMaximize, }) => {\n    return html `\n    ${array.map((item, index) => html `${dump({\n        value: paramValueKeys(item, columnNames),\n        showLevels,\n        showAll,\n        showKids: showAll || showKids,\n        isRootDump: false,\n        formatChange,\n        onHeaderClick: toggleColumnDialog,\n        allowMaximize\n    })}`.key({ item: item, index }))}\n  `;\n});\nfunction paramValueKeys(inputObject, keysArray) {\n    if (['string', 'number', 'boolean'].includes(typeof (inputObject))) {\n        return inputObject;\n    }\n    return filterObjectByKeys(inputObject, keysArray);\n}\nfunction filterObjectByKeys(inputObject, keysArray) {\n    const filteredObject = {};\n    keysArray.forEach(key => {\n        if (inputObject.hasOwnProperty(key)) {\n            filteredObject[key] = inputObject[key];\n        }\n    });\n    return filteredObject;\n}\n//# sourceMappingURL=arrayDisplay.tag.js.map","import { html, tag } from \"taggedjs\";\nimport { dump } from \"./index\";\nexport const arrayTable = tag(({ array, \n// showLevels,\nshowAll, showKids, toggleColumnDialog, columnNames, formatChange, allowMaximize, }) => {\n    return html `<!-- array table -->\n    <!-- overflow-y: scroll; -->\n    <div style=\"max-height: 800px;max-width:100vw;overflow: scroll;\">\n      <table cellPadding=\"2\" cellSpacing=\"2\" border=\"0\">\n        ${array.length && html `\n          <thead style=\"position: sticky;top: 0;font-size: 0.8em;\">\n            <tr>\n              ${columnNames.map(key => html `\n                <th\n                  style.cursor=${toggleColumnDialog && 'pointer'}\n                  onclick=${toggleColumnDialog}\n                >${key}</th>\n              `.key(key))}\n            </tr>\n          </thead>\n        `}\n        <tbody>\n          ${array.map(row => html `\n            <tr>\n              ${columnNames.map(name => html `\n                <td>\n                  ${dump({\n        value: row[name],\n        showLevels: 0,\n        showAll,\n        showKids: showAll || showKids,\n        isRootDump: false,\n        formatChange,\n        allowMaximize,\n    })}\n                </td>\n              `.key(row[name]))}\n            </tr>\n          `.key(row))}\n        </tbody>\n      </table>\n    </div>\n  `;\n});\n//# sourceMappingURL=arrayTable.component.js.map","import { columnEditor } from \"./columnEditor.component\";\nimport { html, state, letState, tag } from \"taggedjs\";\nimport { arrayTable } from \"./arrayTable.component\";\nimport { arrayDisplay } from \"./arrayDisplay.tag\";\nexport const arraysDisplay = tag(({ showLevels, showAll, showKids, array, arrayView, formatChange, allowMaximize, }) => {\n    const allColumnNames = array.length ? Object.keys(array[0]) : [];\n    let columnNames = letState(allColumnNames)(x => [columnNames, columnNames = x]);\n    let showColumnDialog = letState(false)(x => [showColumnDialog, showColumnDialog = x]);\n    let uniqueId = state('columnDialog' + performance.now());\n    const toggleColumnDialog = () => {\n        showColumnDialog = !showColumnDialog;\n        const element = document.getElementById(uniqueId);\n        if (showColumnDialog) {\n            element.showModal();\n        }\n        else {\n            element.close(); // <- element has onclose event that is called slow\n        }\n    };\n    const arrayTag = arrayView === 'table' ? arrayTable({\n        showAll, showKids,\n        array, toggleColumnDialog, columnNames,\n        formatChange,\n    }) : arrayDisplay({\n        array, showLevels, showAll, showKids,\n        formatChange,\n        columnNames,\n        toggleColumnDialog,\n        allowMaximize\n    });\n    return html `\n    ${arrayTag}\n\n    <dialog id=${uniqueId} class=\"dump-dialog\" style=\"padding:0\"\n      onmousedown=\"var r = this.getBoundingClientRect();(r.top<=event.clientY&&event.clientY<=r.top+r.height&&r.left<=event.clientX&&event.clientX<=r.left+r.width) || this.close()\"\n      ondragstart=\"const {e,dt,t} = {t:this,e:event,dt:event.dataTransfer};const d=t.drag=t.drag||{x:0,y:0};d.initX=d.x;d.startX=event.clientX-t.offsetLeft;d.startY=event.clientY-t.offsetTop;t.ondragover=e.target.ondragover=(e)=>e.preventDefault();dt.effectAllowed='move';dt.dropEffect='move'\"\n      ondrag=\"const {t,e,dt,d}={e:event,dt:event.dataTransfer,d:this.drag}; if(e.clientX===0) return;d.x = d.x + e.offsetX - d.startX; d.y = d.y + e.offsetY - d.startY; this.style.left = d.x + 'px'; this.style.top = d.y+'px';\"\n      ondragend=\"const {t,e,d}={t:this,e:event,d:this.drag};if (d.initX === d.x) {d.x=d.x+e.offsetX-(d.startX-d.x);d.y=d.y+e.offsetY-(d.startY-d.y);this.style.transform=translate3d(d.x+'px', d.y+'px', 0)};this.draggable=false\"\n      onclose=${() => {\n        showColumnDialog = false;\n    }}\n    >\n      <div\n        style=\"padding:.25em;background-color:#666;color:white;\"\n        onmousedown=\"this.parentNode.draggable=true\"\n      >Column Modifier</div>\n      <div style=\"padding:.25em\">\n        ${allColumnNames.map(name => {\n        const included = columnNames.includes(name);\n        return html `\n            <div\n              style=\"display:flex;justify-content: space-between;flex-wrap:wrap\"\n              class=\"hover-bg-warning\"\n            >\n              ${columnEditor({\n            name,\n            array,\n            included,\n            columnNames,\n            allColumnNames,\n        })}\n            </div>\n          `.key(name);\n    })}\n        <button style=\"width:100%\" type=\"button\" onclick=${toggleColumnDialog}>🅧 close</button>\n      </div>\n    </dialog>\n  `;\n});\n//# sourceMappingURL=arraysDisplay.component.js.map","import { html, state, letState, tag } from \"taggedjs\";\nexport const columnEditor = tag(({ name, array, included, columnNames, allColumnNames }) => {\n    let mouseOverEditShow = letState(false)(x => [mouseOverEditShow, mouseOverEditShow = x]);\n    let edit = letState(false)(x => [edit, edit = x]);\n    let editFormula = letState(undefined)(x => [editFormula, editFormula = x]);\n    const formulas = state([]);\n    const filterNames = () => {\n        if (included) {\n            columnNames.length = 0;\n            columnNames.push(...columnNames.filter(n => n !== name));\n            return;\n        }\n        columnNames.push(name);\n    };\n    const goAll = () => {\n        columnNames.length = 0;\n        columnNames.push(...allColumnNames);\n    };\n    const goOnly = () => {\n        columnNames.length = 0;\n        columnNames.push(name);\n    };\n    const addSumFormula = () => {\n        const stringFormula = `\n      array.reduce((all, item) => {\n        const value = item['${name}']\n        return isNaN(value) ? all : (all + value)\n      }, 0)\n    `;\n        formulas.push({\n            title: 'sum',\n            stringFormula,\n            value: sandboxRunEval(stringFormula, { array })\n        });\n        // console.log('formulas', formulas.length)\n    };\n    const updateFormula = (formula, newFormula) => {\n        formula.stringFormula = newFormula;\n        formula.value = sandboxRunEval(newFormula, { array });\n    };\n    return html `\n    <a onclick=${filterNames} style=\"cursor:pointer;\">\n      <input type=\"checkbox\" ${included && 'checked'} />&nbsp;${name}\n    </a>\n\n    <div\n      onmouseover=${() => mouseOverEditShow = true}\n      onmouseout=${() => mouseOverEditShow = false}\n    >\n      <a style.visibility=${(edit || mouseOverEditShow) ? 'visible' : 'hidden'}\n        onclick=${() => edit = !edit}\n      >⚙️&nbsp;</a>\n      \n      ${included && columnNames.length !== allColumnNames.length ? html `\n        <a style=\"color:blue;\" onclick=${goAll}><small>all</small></a>\n      ` : html `\n        <a style=\"color:blue;\" onclick=${goOnly}><small>only</small></a>\n      `}\n    </div>\n\n    ${edit && html `\n      <div style=\"width:100%;padding:0.3em;\">\n        <div style=\"font-size:0.7em;text-align:center;\">\n          <strong>Column Settings</strong>\n        </div>\n        <div>\n          ${editFormula && html `\n            <div style=\"padding:0.3em;\">\n              <strong>edit formula</strong>\n            </div>\n            <textarea wrap=\"off\"\n              onchange=${(evt) => updateFormula(editFormula, evt.target.value)}\n            >${editFormula.value}</textarea>\n          `}\n          <div style=\"display:flex;flex-wrap:wrap;gap:1em\">\n            ${formulas.map(formula => html `\n                <div>\n                  <div>\n                    <strong>${formula.title}</strong>\n                    <a onclick=${() => editFormula = formula}>✏️</a>\n                  </div>\n                  <div>${formula.value}</div>\n                </div>\n              `.key(formula))}\n          </div>\n          <button type=\"button\" onclick=${addSumFormula}>sum</button>\n        </div>\n      </div>\n    `}\n  `;\n});\nfunction sandboxRunEval(stringFormula, context = {}) {\n    return sandboxEval(stringFormula, { isNaN, Math, Number, Date, ...context });\n}\n// execute script in private context\nfunction sandboxEval(src, ctx) {\n    if (!src) {\n        return src;\n    }\n    ctx = new Proxy(ctx, { has: () => true });\n    let func = (new Function(\"with(this) { return (\" + src + \")}\"));\n    return func.call(ctx);\n}\n//# sourceMappingURL=columnEditor.component.js.map","import { html, tag } from \"taggedjs\";\nimport { copyText } from \"./copyText.function\";\nexport const controlPanel = tag(({ value, format, showAll, formatChange, showAllChange, }) => {\n    return html `\n    <style>\n      dialog.dump-dialog::backdrop {\n        background-color: rgba(0, 0, 0, 0.7); /* Set a semi-transparent black background */\n      }\n\n      .child-margin-xxs {margin:0.2em;}\n      \n      .taggedjs-dump .hover-bg-warning:hover {background-color:#fcf8e3}\n      .taggedjs-dump .hover-bg-balanced:hover {background-color:#33cd5f}\n      .taggedjs-dump .active-bg-energized:active {background-color:#ffc900}\n      .taggedjs-dump .bg-dark {background-color:#444444}\n      .taggedjs-dump .bg-balanced {background-color:#33cd5f}\n    </style>\n    <div style=\"width: 100%;line-height: 90%;\">\n      <div style=\"position:relative;\">\n        <div style=\"display:flex;font-size:50%;position:absolute;top:-18px;right:-6px\">\n          ${!format || format === 'flex' && html `\n            <a\n              style=${\"margin:1px;border-radius:5px;color:white;align-items:center;display:flex;padding-left:0.2em;padding-right:0.2em;\" +\n        (showAll ? 'background-color:#33cd5f;' : 'background-color:#444444')}\n              class=\"hover-bg-balanced\"\n              onclick=${() => showAllChange(showAll = !showAll)}\n              title=\"hide/show all sub objects\"\n            >👁</a>\n          `}\n          <a\n            style=${\"margin:1px;border-radius:5px;color:white;align-items:center;display:flex;padding-left:0.2em;padding-right:0.2em;\" +\n        (!format || format === 'flex' ? 'background-color:#33cd5f;' : 'background-color:#444444')}\n            class=\"hover-bg-balanced\"\n            onclick=${() => formatChange(format = 'flex')}\n          >flex</a>\n          <a style=${\"margin:1px;border-radius:5px;color:white;align-items:center;display:flex;padding-left:0.2em;padding-right:0.2em;\" +\n        (format === 'json' ? 'background-color:#33cd5f;' : 'background-color:#444444')}\n            class=\"hover-bg-balanced\"\n            onclick=${() => formatChange(format = 'json')}\n          >json</a>\n          <a style=\"margin:1px;border-radius:5px;color:white;align-items:center;display:flex;padding-left:0.2em;padding-right:0.2em;\"\n            class=\"bg-dark hover-bg-balanced active-bg-energized\"\n            onclick=${() => copyAsJsonText(value)}\n          >copy</a>\n        </div>\n      </div>\n    </div>\n  `;\n});\nfunction copyAsJsonText(value) {\n    const text = JSON.stringify(value, null, 2);\n    copyText(text);\n}\n//# sourceMappingURL=controlPanel.tag.js.map","export function copyText(text) {\n    var copyText = document.createElement('textarea');\n    copyText.value = text;\n    document.body.appendChild(copyText);\n    copyText.select();\n    copyText.setSelectionRange(0, 99999);\n    document.execCommand(\"copy\");\n    document.body.removeChild(copyText);\n}\n//# sourceMappingURL=copyText.function.js.map","import { html, onInit, letState, setProp, tag } from \"taggedjs\";\nimport { dumpArray } from \"./dumpArray.tag\";\nimport { dumpSimple } from \"./dumpSimple.tag\";\nimport { dumpObject } from \"./dumpObject.tag\";\nimport { controlPanel } from \"./controlPanel.tag\";\nexport const dump = tag(({ // dump tag\nkey, value, showKids = false, showLevels = -1, showAll = false, format = 'flex', formatChange = x => format = x, isRootDump = true, onHeaderClick, allowMaximize, }) => {\n    if (isRootDump && allowMaximize == undefined) {\n        allowMaximize = true;\n    }\n    console.log('allowMaximize', allowMaximize);\n    const isObject = () => value && value instanceof Object;\n    const typing = value === null ? 'null' : typeof (value);\n    let show = letState(false)(x => [show, show = x]);\n    setProp(x => [format, format = x]);\n    setProp(x => [showAll, showAll = x]);\n    let arrayView = letState(undefined)(x => [arrayView, arrayView = x]);\n    onInit(() => {\n        const levelsDefined = (showLevels >= 0 && showLevels);\n        // detect auto levels (default) and if object lets only show 2 levels deep\n        const autoShowObjectLevels = showLevels === -1 && !key && isObject();\n        showLevels = levelsDefined || (autoShowObjectLevels ? 2 : 0);\n        if (showLevels > 0) {\n            show = true;\n        }\n    });\n    /* IF 3: object value */\n    function objectTemplate() {\n        if (value === null) {\n            if (!showKids) {\n                return html ``;\n            }\n            return dumpSimple({\n                key: key,\n                value: 'null',\n                onHeaderClick\n            });\n        }\n        const isArray = (!format || format === 'flex') && (value.push && value.pop);\n        return html `\n      <div class=\"taggedjs-dump\">\n        ${isRootDump && controlPanel({\n            value,\n            format,\n            showAll,\n            showAllChange: x => showAll = x,\n            formatChange,\n        })}\n        ${(format === 'json' && html `\n          <textarea *ngIf=\"\" disabled wrap=\"off\" style=\"width:100%;height:25vh;min-height:400px;color:white;\"\n          >${JSON.stringify(value, null, 2)}</textarea>\n        `) || ((isArray && dumpArray({\n            key,\n            value,\n            show,\n            // arrayView,\n            showAll,\n            showKids,\n            showLevels,\n            formatChange,\n            allowMaximize,\n        })) ||\n            dumpObject({\n                key,\n                show,\n                // showChange: x => showChangeValue(show = x),\n                showKids,\n                showLevels,\n                value,\n                showAll,\n                formatChange,\n                onHeaderClick,\n                allowMaximize,\n            }))}\n      </div>\n    `;\n    }\n    /* IF 1: undefined ELSE goto simpleTemplate */\n    if ([null, undefined].includes(value)) {\n        return dumpSimple({\n            key: key,\n            value: typing,\n            onHeaderClick\n        });\n    }\n    /* IF 2: simple value ELSE goto objectTemplate */\n    if (['boolean', 'number', 'string'].includes(typing)) {\n        return dumpSimple({ key: key, value, onHeaderClick });\n    }\n    return objectTemplate();\n});\n//# sourceMappingURL=dump.tag.js.map","import { arraysDisplay } from \"./arraysDisplay.component\";\nimport { html, letState, tag, watch } from \"taggedjs\";\nexport const dumpArray = tag(({ // dumpArray\nkey, value, show, showAll, showKids, \n// arrayView,\nshowLevels, formatChange, allowMaximize, }) => {\n    let showValue = letState(false)(x => [showValue, showValue = x]);\n    let arrayView = letState(undefined)(x => [arrayView, arrayView = x]);\n    watch([show], ([show]) => showValue = show);\n    return html `<!-- array -->\n  <div\n    style=\"color:#111111;background-color:#f2dede;border:1px solid black;border-radius:5px;flex-direction: column;display:flex\"\n  >\n    <div\n      style=${\"padding:0.2em;display:flex;justify-content:space-between;flex-grow:1;font-size:65%;border-color:white;color:white;background-color:#ef473a;\" +\n        (showValue ? 'border-bottom-width:1px;border-bottom-style:solid;border-color:black;' : '')}\n    >\n      <a style=\"flex-grow:1\" onclick=${() => {\n        showValue = !showValue;\n    }}>\n        <strong>${key}</strong>\n      </a>\n      <sup style=\"opacity:80%;font-size:75%;padding-left:0.4em\">\n        <a style=\"text-decoration:underline;\" style.font-weight=${arrayView === 'table' ? 'bold' : ''}\n          onclick=${() => arrayView = arrayView === 'table' ? undefined : 'table'}>${arrayView === 'table' ? 'flex' : 'table'}</a>\n      </sup>\n      <sup style=\"opacity:80%;font-size:75%;padding-left:0.4em\">[${value.length}]</sup>\n      ${allowMaximize && '🪟'}\n    </div>\n    \n    ${(showAll || showValue || showKids || (showValue == undefined && showLevels > 0)) && html `\n      <!-- array displays wrap -->\n      <div style=\"text-align:left;display:flex;flex-wrap:wrap;margin:0.2em;gap:0.2em\">\n        ${arraysDisplay({\n        showLevels, showAll, showKids,\n        formatChange,\n        array: value,\n        arrayView: arrayView,\n        allowMaximize,\n    })}\n      </div>\n    `}\n  </div>\n  `;\n});\n//# sourceMappingURL=dumpArray.tag.js.map","import { html, letState, state, tag, watch } from \"taggedjs\";\nimport { dump } from \"./index\";\nexport const dumpObject = tag(({ // dumpObject\nkey, showKids, show, showLevels, value, showAll, onHeaderClick, formatChange, allowMaximize, }) => {\n    let showLower = letState(false)(x => [showLower, showLower = x]);\n    let maximize = letState(false)(x => [maximize, maximize = x]);\n    const maximizeId = state(() => 'maximize-dump-' + performance.now());\n    watch([show], ([show]) => showLower = show);\n    const continueDump = !key || showKids || showLower || (showLower == undefined && showLevels > 0);\n    const toggleMaximize = () => {\n        maximize = !maximize;\n        if (maximize) {\n            document.getElementById(maximizeId).showModal();\n        }\n    };\n    const minimize = () => document.getElementById(maximizeId).close();\n    return html `\n    <div style=\"flex: 1 1 10em;text-align:left;\">\n      <div\n        style=\"font-size:90%;color:#111111;background-color:#d9edf7;border:1px solid black;border-radius:5px;flex-direction: column;display:flex;\"\n      >\n        ${key && html `\n          <div style=${\"padding:0.2em;display:flex;justify-content:space-between;font-size:65%;color:white;border-color:white;flex-grow:1;background-color:#387ef5;\" +\n        (showLower ? 'border-bottom-width:1px;border-bottom-style:solid;border-color:black;' : '')}\n          >\n            <a onclick=${() => showLower = !showLower}>\n              <strong>${key}</strong>\n              <sup style=\"opacity:80%;font-size:75%;padding-left:0.4em\">\n                {${Object.keys(value).length}}\n              </sup>\n            </a>\n            ${allowMaximize && html `\n              <a onclick=${toggleMaximize}>🪟</a>\n            `}\n          </div>\n        `}\n        \n        ${continueDump && html `\n          <div style=\"display:flex;flex-wrap:wrap\">\n            ${Object.entries(value).map(([key, value]) => html `\n              <!-- recurse -->\n              <div class=\"child-margin-xxs\"\n                style=${'padding:0.2em;overflow:auto;display:flex;flex-wrap:wrap;' +\n        (!value || typeof (value) !== 'object' ? 'flex: 1 1 10em;' : 'flex-grow:1;')}\n              >\n                ${dump({\n        value,\n        key,\n        show: showLower,\n        showAll,\n        showLevels: showLevels - 1,\n        showKids: showAll || showKids,\n        isRootDump: false,\n        formatChange,\n        onHeaderClick,\n        allowMaximize,\n    })}\n            `.key([key, value]))}\n          </div>\n        `}\n\n        <!-- maximize -->\n        <dialog id=${maximizeId} style=\"padding:0\"\n          onmousedown=\"var r = this.getBoundingClientRect();(r.top<=event.clientY&&event.clientY<=r.top+r.height&&r.left<=event.clientX&&event.clientX<=r.left+r.width) || this.close()\"\n          ondragstart=\"const {e,dt,t} = {t:this,e:event,dt:event.dataTransfer};const d=t.drag=t.drag||{x:0,y:0};d.initX=d.x;d.startX=event.clientX-t.offsetLeft;d.startY=event.clientY-t.offsetTop;t.ondragover=e.target.ondragover=(e)=>e.preventDefault();dt.effectAllowed='move';dt.dropEffect='move'\"\n          ondrag=\"const {t,e,dt,d}={e:event,dt:event.dataTransfer,d:this.drag}; if(e.clientX===0) return;d.x = d.x + e.offsetX - d.startX; d.y = d.y + e.offsetY - d.startY; this.style.left = d.x + 'px'; this.style.top = d.y+'px';\"\n          ondragend=\"const {t,e,d}={t:this,e:event,d:this.drag};if (d.initX === d.x) {d.x=d.x+e.offsetX-(d.startX-d.x);d.y=d.y+e.offsetY-(d.startY-d.y);this.style.transform=translate3d(d.x+'px', d.y+'px', 0)};this.draggable=false\"\n        >\n          <div style=\"padding:.25em\" onmousedown=\"this.parentNode.draggable=true\"\n          >dialog title</div>\n          \n          ${maximize && html `\n            hello world\n          `}\n\n          <div style=\"padding:.25em\">\n            <button type=\"button\" onclick=${minimize}>🅧 close</button>\n          </div>\n        </dialog>\n      </div>\n    </div>\n  `;\n});\n//# sourceMappingURL=dumpObject.tag.js.map","import { html, letState, tag } from \"taggedjs\";\nimport { copyText } from \"./copyText.function\";\nexport function dumpSimple({ key, value, onHeaderClick }) {\n    const isLinkValue = value.search && (value.slice(0, 8) === 'https://' || value.slice(0, 7) === 'http://');\n    return html `\n    <div style=\"font-size:75%;flex:1 1 10em;color:#111111\">\n      ${key && html `\n        <div style=\"border-bottom-width:1px;border-bottom-style:solid;border-color:black;font-size:65%;border-color:white;line-height: 95%;font-weight:bold;\"\n          style.cursor=${onHeaderClick && \"pointer\"}\n          onclick=${onHeaderClick}\n        >${key}</div>\n      `}\n      ${isLinkValue ? linkValue(value) : simpleValue(value)}\n    </div>\n  `;\n}\nconst simpleValue = tag((value) => {\n    const isLikeNull = [undefined, null, 'null'].includes(value);\n    const number = value;\n    const isLargeNumber = !isNaN(number) && number > 1000000000;\n    const title = !isLargeNumber ? '' : getLargeNumberTitle(number);\n    let downTime = letState(0)(x => [downTime, downTime = x]);\n    const startMouseDown = () => {\n        downTime = Date.now();\n    };\n    const markMouseUp = (event) => {\n        if (Date.now() - downTime > 300) {\n            event.preventDefault();\n            event.stopPropagation();\n            console.log('xx');\n            return true; // a manual drag copy is taking place\n        }\n        console.log('copied');\n        copyText(value); // a regular click took place\n    };\n    return html `\n    <div class=\"hover-bg-warning active-bg-energized\"\n      onmousedown=${startMouseDown}\n      onmouseup=${markMouseUp}\n      style=\"cursor:pointer;\"\n      style.background-color=${isLikeNull ? 'rgba(0,0,0,.5)' : ''}\n      style.color = ${(value === true && '#28a54c') ||\n        (value === false && '#e42112') ||\n        isLikeNull && 'white' || ''}\n      title=${title}\n    >${value === null && 'null' || value === false && 'false' || value === undefined && 'undefined' || value}</div>\n  `;\n});\nfunction getLargeNumberTitle(number) {\n    return number > 946702800000 ?\n        'Milliseconds > Unix epoch:\\n' + (new Date(number).toLocaleString()) :\n        'Seconds > Unix epoch:\\n' + (new Date(number * 1000).toLocaleString());\n}\nconst linkValue = (value) => {\n    return html `\n    <a onclick=${() => copyText(value)} href=${value}\n      target=\"_blank\"\n      class=\"hover-bg-warning active-bg-energized\"\n      title=\"tap to copy\"\n    >${value}</a>\n  `;\n};\n//# sourceMappingURL=dumpSimple.tag.js.map","export { dump } from './dump.tag';\n//# sourceMappingURL=index.js.map","export const stripeList = {\n    \"object\": \"list\",\n    \"data\": [\n        {\n            \"id\": \"pi_2On6sU7HNYdnrRlv08gdQmRW\",\n            \"object\": \"payment_intent\",\n            \"amount\": 210023,\n            \"amount_capturable\": 0,\n            \"amount_details\": {\n                \"tip\": {}\n            },\n            \"amount_received\": 0,\n            \"application\": null,\n            \"application_fee_amount\": null,\n            \"automatic_payment_methods\": null,\n            \"canceled_at\": null,\n            \"cancellation_reason\": null,\n            \"capture_method\": \"automatic\",\n            \"charges\": {\n                \"object\": \"list\",\n                \"data\": [\n                    {\n                        \"id\": \"py_2On6sU7ENs46345345\",\n                        \"object\": \"charge\",\n                        \"amount\": 210023,\n                        \"amount_captured\": 210023,\n                        \"amount_refunded\": 0,\n                        \"application\": null,\n                        \"application_fee\": null,\n                        \"application_fee_amount\": null,\n                        \"balance_transaction\": null,\n                        \"billing_details\": {\n                            \"address\": {\n                                \"city\": null,\n                                \"country\": null,\n                                \"line1\": null,\n                                \"line2\": null,\n                                \"postal_code\": null,\n                                \"state\": null\n                            },\n                            \"email\": \"nothing@yahoo.com\",\n                            \"name\": \"Super One force\",\n                            \"phone\": null\n                        },\n                        \"calculated_statement_descriptor\": null,\n                        \"captured\": true,\n                        \"created\": 1708725963,\n                        \"currency\": \"usd\",\n                        \"customer\": \"cus_\",\n                        \"description\": \"stock package pack198\",\n                        \"destination\": null,\n                        \"dispute\": null,\n                        \"disputed\": false,\n                        \"failure_balance_transaction\": null,\n                        \"failure_code\": null,\n                        \"failure_message\": null,\n                        \"fraud_details\": {},\n                        \"invoice\": null,\n                        \"livemode\": true,\n                        \"metadata\": {},\n                        \"on_behalf_of\": null,\n                        \"order\": null,\n                        \"outcome\": null,\n                        \"paid\": false,\n                        \"payment_intent\": \"pi_2On6sU234234234\",\n                        \"payment_method\": \"pm_1OjSol23423423442\",\n                        \"payment_method_details\": {\n                            \"type\": \"us_bank_account\",\n                            \"us_bank_account\": {\n                                \"account_holder_type\": \"individual\",\n                                \"account_type\": \"checking\",\n                                \"bank_name\": \"JPMORGAN CHASE BANK, NA\",\n                                \"fingerprint\": \"asdfsfsfsd\",\n                                \"last4\": \"3072\",\n                                \"routing_number\": \"sfsdfsdfs\"\n                            }\n                        },\n                        \"radar_options\": {},\n                        \"receipt_email\": \"nothing@yahoo.com\",\n                        \"receipt_number\": null,\n                        \"receipt_url\": null,\n                        \"refunded\": false,\n                        \"refunds\": {\n                            \"object\": \"list\",\n                            \"data\": [],\n                            \"has_more\": false,\n                            \"total_count\": 0,\n                            \"url\": \"/v1/charges/py_2On6sU7ENYdn23423423423423/refunds\"\n                        },\n                        \"review\": null,\n                        \"shipping\": null,\n                        \"source\": null,\n                        \"source_transfer\": null,\n                        \"statement_descriptor\": null,\n                        \"statement_descriptor_suffix\": null,\n                        \"status\": \"pending\",\n                        \"transfer_data\": null,\n                        \"transfer_group\": null\n                    }\n                ],\n                \"has_more\": false,\n                \"total_count\": 1,\n                \"url\": \"/v1/charges?payment_intent=pi_2On6sU7HNYdnrRlv08gdQmRW\"\n            },\n            \"client_secret\": \"pi_2On6sU7HNYdnrRlv08gdQmRW_secret_mi91s3ThhlbiFNYtJZkw7aeuj\",\n            \"confirmation_method\": \"automatic\",\n            \"created\": 1708725958,\n            \"currency\": \"usd\",\n            \"customer\": \"cus_\",\n            \"description\": \"stock package pack198\",\n            \"invoice\": null,\n            \"last_payment_error\": null,\n            \"latest_charge\": \"py_2On6sU7ENYdn23423423423423\",\n            \"livemode\": true,\n            \"metadata\": {},\n            \"next_action\": null,\n            \"on_behalf_of\": null,\n            \"payment_method\": \"pm_0OjSol7ENYdnrElvxSEFqCs3\",\n            \"payment_method_configuration_details\": null,\n            \"payment_method_options\": {\n                \"us_bank_account\": {\n                    \"mandate_options\": {},\n                    \"verification_method\": \"automatic\"\n                }\n            },\n            \"payment_method_types\": [\n                \"us_bank_account\"\n            ],\n            \"processing\": null,\n            \"receipt_email\": \"nothing@yahoo.com\",\n            \"review\": null,\n            \"setup_future_usage\": null,\n            \"shipping\": null,\n            \"source\": null,\n            \"statement_descriptor\": null,\n            \"statement_descriptor_suffix\": null,\n            \"status\": \"processing\",\n            \"transfer_data\": null,\n            \"transfer_group\": null\n        },\n        {\n            \"id\": \"pi_2On6rP7ENY234234234223\",\n            \"object\": \"pa345345345\",\n            \"amount\": 459142,\n            \"amount_capturable\": 0,\n            \"amount_details\": {\n                \"tip\": {}\n            },\n            \"amount_received\": 0,\n            \"application\": null,\n            \"application_fee_amount\": null,\n            \"automatic_payment_methods\": null,\n            \"canceled_at\": null,\n            \"cancellation_reason\": null,\n            \"capture_method\": \"automatic\",\n            \"charges\": {\n                \"object\": \"list\",\n                \"data\": [\n                    {\n                        \"id\": \"py_2On6rP7ENYdnrElv34534534534\",\n                        \"object\": \"charge\",\n                        \"amount\": 459142,\n                        \"amount_captured\": 459142,\n                        \"amount_refunded\": 0,\n                        \"application\": null,\n                        \"application_fee\": null,\n                        \"application_fee_amount\": null,\n                        \"balance_transaction\": null,\n                        \"billing_details\": {\n                            \"address\": {\n                                \"city\": null,\n                                \"country\": null,\n                                \"line1\": null,\n                                \"line2\": null,\n                                \"postal_code\": null,\n                                \"state\": null\n                            },\n                            \"email\": \"nothing@nothing.com\",\n                            \"name\": \"high times life\",\n                            \"phone\": null\n                        },\n                        \"calculated_statement_descriptor\": null,\n                        \"captured\": true,\n                        \"created\": 1708725908,\n                        \"currency\": \"usd\",\n                        \"customer\": \"cus_OfpNBU2342342342\",\n                        \"description\": \"stock package CST422199\",\n                        \"destination\": null,\n                        \"dispute\": null,\n                        \"disputed\": false,\n                        \"failure_balance_transaction\": null,\n                        \"failure_code\": null,\n                        \"failure_message\": null,\n                        \"fraud_details\": {},\n                        \"invoice\": null,\n                        \"livemode\": true,\n                        \"metadata\": {},\n                        \"on_behalf_of\": null,\n                        \"order\": null,\n                        \"outcome\": null,\n                        \"paid\": false,\n                        \"payment_intent\": \"pi_2On6rP7ENY234234234223\",\n                        \"payment_method\": \"pm_0NsTld7E345345345\",\n                        \"payment_method_details\": {\n                            \"type\": \"us_bank_account\",\n                            \"us_bank_account\": {\n                                \"account_holder_type\": \"individual\",\n                                \"account_type\": \"checking\",\n                                \"bank_name\": \"LEFT RIGHT CREDIT UNION INC\",\n                                \"fingerprint\": \"sdfsdfsdfsd\",\n                                \"last4\": \"7164\",\n                                \"routing_number\": \"24427435345634\"\n                            }\n                        },\n                        \"radar_options\": {},\n                        \"receipt_email\": \"nothing@nothing.com\",\n                        \"receipt_number\": null,\n                        \"receipt_url\": null,\n                        \"refunded\": false,\n                        \"refunds\": {\n                            \"object\": \"list\",\n                            \"data\": [],\n                            \"has_more\": false,\n                            \"total_count\": 0,\n                            \"url\": \"/v1/charges/py_2On6rP7ENYdnrElv34534534534/refunds\"\n                        },\n                        \"review\": null,\n                        \"shipping\": null,\n                        \"source\": null,\n                        \"source_transfer\": null,\n                        \"statement_descriptor\": null,\n                        \"statement_descriptor_suffix\": null,\n                        \"status\": \"pending\",\n                        \"transfer_data\": null,\n                        \"transfer_group\": null\n                    }\n                ],\n                \"has_more\": false,\n                \"total_count\": 1,\n                \"url\": \"/v1/charges?payment_intent=pi_2On6rP7ENY23423345345345\",\n                \"client_secret\": \"pi_2On6rP7ENY234234234223_secret_coB4G9HHl1eq5B17Q2C8CSvIr\"\n            },\n            \"confirmation_method\": 345345345,\n            \"created\": 1708725891,\n            \"currency\": \"usd\",\n            \"customer\": \"cus_OfpNBU2342342342\",\n            \"description\": \"stock package CST422199\",\n            \"invoice\": null,\n            \"last_payment_error\": null,\n            \"latest_charge\": \"py_2On6rP7ENYdnrElv34534534534\",\n            \"livemode\": true,\n            \"metadata\": {},\n            \"next_action\": null,\n            \"on_behalf_of\": null,\n            \"payment_method\": \"pm_0NsTld7ENYdnrElvZnMTXy4p\",\n            \"payment_method_configuration_details\": null,\n            \"payment_method_options\": {\n                \"us_bank_account\": {\n                    \"mandate_options\": {},\n                    \"verification_method\": \"automatic\"\n                }\n            },\n            \"payment_method_types\": [\n                \"us_bank_account\"\n            ],\n            \"processing\": null,\n            \"receipt_email\": \"nothing@nothing.com\",\n            \"review\": null,\n            \"setup_future_usage\": null,\n            \"shipping\": null,\n            \"source\": null,\n            \"statement_descriptor\": null,\n            \"statement_descriptor_suffix\": null,\n            \"status\": \"processing\",\n            \"transfer_data\": null,\n            \"transfer_group\": null\n        },\n        {\n            \"id\": \"pi_2On6qz7ENYdnrElv0iAjkQXG\",\n            \"object\": \"payment_intent\",\n            \"amount\": 353001,\n            \"amount_capturable\": 0,\n            \"amount_details\": {\n                \"tip\": {}\n            },\n            \"amount_received\": 0,\n            \"application\": null,\n            \"application_fee_amount\": null,\n            \"automatic_payment_methods\": null,\n            \"canceled_at\": null,\n            \"cancellation_reason\": null,\n            \"capture_method\": \"automatic\",\n            \"charges\": {\n                \"object\": \"list\",\n                \"data\": [\n                    {\n                        \"id\": \"py_2On6qz7ENYdnrElv03EQXijt\",\n                        \"object\": \"charge\",\n                        \"amount\": 353001,\n                        \"amount_captured\": 353001,\n                        \"amount_refunded\": 0,\n                        \"application\": null,\n                        \"application_fee\": null,\n                        \"application_fee_amount\": null,\n                        \"balance_transaction\": null,\n                        \"billing_details\": {\n                            \"address\": {\n                                \"city\": null,\n                                \"country\": null,\n                                \"line1\": null,\n                                \"line2\": null,\n                                \"postal_code\": null,\n                                \"state\": null\n                            },\n                            \"email\": \"goonta1621@gmail.com\",\n                            \"name\": \"Imodern LLC\",\n                            \"phone\": null\n                        },\n                        \"calculated_statement_descriptor\": null,\n                        \"captured\": true,\n                        \"created\": 1708725871,\n                        \"currency\": \"usd\",\n                        \"customer\": \"cus_OPju332LNrDqWj\",\n                        \"description\": \"stock package CST422875\",\n                        \"destination\": null,\n                        \"dispute\": null,\n                        \"disputed\": false,\n                        \"failure_balance_transaction\": null,\n                        \"failure_code\": null,\n                        \"failure_message\": null,\n                        \"fraud_details\": {},\n                        \"invoice\": null,\n                        \"livemode\": true,\n                        \"metadata\": {\n                            \"fullOrderId\": \"CST422875\",\n                            \"orderId\": \"422875\"\n                        },\n                        \"on_behalf_of\": null,\n                        \"order\": null,\n                        \"outcome\": null,\n                        \"paid\": false,\n                        \"payment_intent\": \"pi_2On6qz7ENYdnrElv0iAjkQXG\",\n                        \"payment_method\": \"pm_0Ojnzp7ENYdnrElvehXEBmJk\",\n                        \"payment_method_details\": {\n                            \"type\": \"us_bank_account\",\n                            \"us_bank_account\": {\n                                \"account_holder_type\": \"individual\",\n                                \"account_type\": \"checking\",\n                                \"bank_name\": \"BANK OF AMERICA, N.A.\",\n                                \"fingerprint\": \"NLhg8mD0tp0uM97N\",\n                                \"last4\": \"2606\",\n                                \"routing_number\": \"011200365\"\n                            }\n                        },\n                        \"radar_options\": {},\n                        \"receipt_email\": \"goonta1621@gmail.com\",\n                        \"receipt_number\": null,\n                        \"receipt_url\": null,\n                        \"refunded\": false,\n                        \"refunds\": {\n                            \"object\": \"list\",\n                            \"data\": [],\n                            \"has_more\": false,\n                            \"total_count\": 0,\n                            \"url\": \"/v1/charges/py_2On6qz7ENYdnrElv03EQXijt/refunds\"\n                        },\n                        \"review\": null,\n                        \"shipping\": null,\n                        \"source\": null,\n                        \"source_transfer\": null,\n                        \"statement_descriptor\": null,\n                        \"statement_descriptor_suffix\": null,\n                        \"status\": \"pending\",\n                        \"transfer_data\": null,\n                        \"transfer_group\": null\n                    }\n                ],\n                \"has_more\": false,\n                \"total_count\": 1,\n                \"url\": \"/v1/charges?payment_intent=pi_2On6qz7ENYdnrElv0iAjkQXG\"\n            },\n            \"client_secret\": \"pi_2On6qz7ENYdnrElv0iAjkQXG_secret_HJlGWDupUqDO2L0BrjfHuRLC2\",\n            \"confirmation_method\": \"automatic\",\n            \"created\": 1708725865,\n            \"currency\": \"usd\",\n            \"customer\": \"cus_OPju332LNrDqWj\",\n            \"description\": \"stock package CST422875\",\n            \"invoice\": null,\n            \"last_payment_error\": null,\n            \"latest_charge\": \"py_2On6qz7ENYdnrElv03EQXijt\",\n            \"livemode\": true,\n            \"metadata\": {\n                \"fullOrderId\": \"CST422875\",\n                \"orderId\": \"422875\"\n            },\n            \"next_action\": null,\n            \"on_behalf_of\": null,\n            \"payment_method\": \"pm_0Ojnzp7ENYdnrElvehXEBmJk\",\n            \"payment_method_configuration_details\": null,\n            \"payment_method_options\": {\n                \"us_bank_account\": {\n                    \"mandate_options\": {},\n                    \"verification_method\": \"automatic\"\n                }\n            },\n            \"payment_method_types\": [\n                \"us_bank_account\"\n            ],\n            \"processing\": null,\n            \"receipt_email\": \"goonta1621@gmail.com\",\n            \"review\": null,\n            \"setup_future_usage\": null,\n            \"shipping\": null,\n            \"source\": null,\n            \"statement_descriptor\": null,\n            \"statement_descriptor_suffix\": null,\n            \"status\": \"processing\",\n            \"transfer_data\": null,\n            \"transfer_group\": null\n        }\n    ],\n    \"has_more\": true,\n    \"url\": \"/v1/payment_intents\"\n};\n","export {};\n","import { runBeforeDestroy } from './tagRunner';\nimport { buildClones } from './render';\nimport { interpolateElement, interpolateString } from './interpolateElement';\nimport { afterElmBuild, subscribeToTemplate } from './interpolateTemplate';\nimport { elementDestroyCheck } from './elementDestroyCheck.function';\nimport { processNewValue } from './processNewValue.function';\nimport { isSubjectInstance, isTagComponent } from './isInstance';\nimport { isLikeTags } from './isLikeTags.function';\nimport { restoreTagMarker } from './checkDestroyPrevious.function';\nexport const variablePrefix = '__tagvar';\nexport const escapeVariable = '--' + variablePrefix + '--';\nconst prefixSearch = new RegExp(variablePrefix, 'g');\nexport const escapeSearch = new RegExp(escapeVariable, 'g');\nexport class Tag {\n    strings;\n    values;\n    version = 0;\n    isTag = true;\n    hasLiveElements = false;\n    clones = []; // elements on document. Needed at destroy process to know what to destroy\n    childTags = []; // tags on me\n    tagSupport;\n    lastTemplateString = undefined; // used to compare templates for updates\n    // only present when a child of a tag\n    ownerTag;\n    // insertBefore?: Element\n    appElement; // only seen on this.getAppElement().appElement\n    // present only when an array. Populated by Tag.key()\n    memory = {};\n    constructor(strings, values) {\n        this.strings = strings;\n        this.values = values;\n    }\n    /** Used for array, such as array.map(), calls aka array.map(x => html``.key(x)) */\n    key(arrayValue) {\n        this.memory.arrayValue = arrayValue;\n        return this;\n    }\n    destroy(options = {\n        stagger: 0,\n        byParent: false, // Only destroy clones of direct children\n    }) {\n        const tagSupport = this.tagSupport;\n        const global = tagSupport.templater.global;\n        const subject = tagSupport.subject;\n        // put back down the template tag\n        const insertBefore = global.insertBefore;\n        if (insertBefore.nodeName === 'TEMPLATE') {\n            const placeholder = global.placeholder;\n            if (placeholder && !('arrayValue' in this.memory)) {\n                if (!options.byParent) {\n                    restoreTagMarker(this, insertBefore);\n                }\n            }\n        }\n        delete global.placeholder;\n        // the isComponent check maybe able to be removed\n        const isComponent = tagSupport ? true : false;\n        if (isComponent) {\n            runBeforeDestroy(tagSupport, this);\n        }\n        const childTags = options.byParent ? [] : getChildTagsToDestroy(this.childTags);\n        // signify that no further event rendering should take place by making logic think a render occurred during event\n        // signify immediately child has been deleted (looked for during event processing)\n        childTags.forEach(child => {\n            const subGlobal = child.tagSupport.templater.global;\n            delete subGlobal.newest;\n            subGlobal.deleted = true;\n        });\n        delete global.oldest;\n        delete global.newest;\n        global.deleted = true;\n        this.hasLiveElements = false;\n        delete subject.tag;\n        this.destroySubscriptions();\n        let mainPromise;\n        if (this.ownerTag) {\n            this.ownerTag.childTags = this.ownerTag.childTags.filter(child => child !== this);\n        }\n        if (!options.byParent) {\n            const { stagger, promise } = this.destroyClones(options);\n            options.stagger = stagger;\n            if (promise) {\n                mainPromise = promise;\n            }\n        }\n        else {\n            this.destroyClones();\n        }\n        if (mainPromise) {\n            mainPromise = mainPromise.then(async () => {\n                const promises = childTags.map(kid => kid.destroy({ stagger: 0, byParent: true }));\n                return Promise.all(promises);\n            });\n        }\n        else {\n            mainPromise = Promise.all(childTags.map(kid => kid.destroy({ stagger: 0, byParent: true })));\n        }\n        return mainPromise.then(() => options.stagger);\n    }\n    destroySubscriptions() {\n        const global = this.tagSupport.templater.global;\n        global.subscriptions.forEach(cloneSub => cloneSub.unsubscribe());\n        global.subscriptions.length = 0;\n    }\n    destroyClones({ stagger } = {\n        stagger: 0,\n    }) {\n        //const promises = this.clones.reverse().map(\n        const promises = this.clones.map(clone => this.checkCloneRemoval(clone, stagger)).filter(x => x); // only return promises\n        this.clones.length = 0; // tag maybe used for something else\n        if (promises.length) {\n            return { promise: Promise.all(promises), stagger };\n        }\n        return { stagger };\n    }\n    /** Reviews elements for the presences of ondestroy */\n    checkCloneRemoval(clone, stagger) {\n        let promise;\n        const customElm = clone;\n        if (customElm.ondestroy) {\n            promise = elementDestroyCheck(customElm, stagger);\n        }\n        const next = () => {\n            clone.parentNode?.removeChild(clone);\n            const ownerTag = this.ownerTag;\n            if (ownerTag) {\n                // Sometimes my clones were first registered to my owner, remove them from owner\n                ownerTag.clones = ownerTag.clones.filter(compareClone => compareClone !== clone);\n            }\n        };\n        if (promise instanceof Promise) {\n            return promise.then(next);\n        }\n        else {\n            next();\n        }\n        return promise;\n    }\n    getTemplate() {\n        const string = this.strings.map((string, index) => {\n            const safeString = string.replace(prefixSearch, escapeVariable);\n            const endString = safeString + (this.values.length > index ? `{${variablePrefix}${index}}` : '');\n            // const trimString = index === 0 || index === this.strings.length-1 ? endString.trim() : endString\n            const trimString = endString.replace(/>\\s*/g, '>').replace(/\\s*</g, '<');\n            return trimString;\n        }).join('');\n        const interpolation = interpolateString(string);\n        this.lastTemplateString = interpolation.string;\n        return {\n            interpolation,\n            // string,\n            string: interpolation.string,\n            strings: this.strings,\n            values: this.values,\n            context: this.tagSupport.templater.global.context || {},\n        };\n    }\n    isLikeTag(tag) {\n        return isLikeTags(this, tag);\n    }\n    updateByTag(tag) {\n        this.tagSupport.templater.global.newest = tag;\n        this.updateConfig(tag.strings, tag.values);\n    }\n    updateConfig(strings, values) {\n        this.strings = strings;\n        this.updateValues(values);\n    }\n    update() {\n        return this.updateContext(this.tagSupport.templater.global.context);\n    }\n    updateValues(values) {\n        this.values = values;\n        return this.updateContext(this.tagSupport.templater.global.context);\n    }\n    updateContext(context) {\n        this.strings.map((_string, index) => {\n            const variableName = variablePrefix + index;\n            const hasValue = this.values.length > index;\n            const value = this.values[index];\n            // is something already there?\n            const exists = variableName in context;\n            if (exists) {\n                return updateContextItem(context, variableName, value);\n            }\n            if (!hasValue) {\n                return;\n            }\n            // 🆕 First time values below\n            context[variableName] = processNewValue(hasValue, value, this);\n        });\n        return context;\n    }\n    getAppElement() {\n        let tag = this;\n        while (tag.ownerTag) {\n            tag = tag.ownerTag;\n        }\n        return tag;\n    }\n    /** Used during HMR only where static content itself could have been edited */\n    rebuild() {\n        // const insertBefore = this.insertBefore\n        const insertBefore = this.tagSupport.templater.global.insertBefore;\n        if (!insertBefore) {\n            const err = new Error('Cannot rebuild. Previous insertBefore element is not defined on tag');\n            err.tag = this;\n            throw err;\n        }\n        this.buildBeforeElement(insertBefore, {\n            forceElement: true,\n            counts: { added: 0, removed: 0 },\n        });\n    }\n    buildBeforeElement(insertBefore, options = {\n        forceElement: false,\n        counts: { added: 0, removed: 0 },\n    }) {\n        const subject = this.tagSupport.subject;\n        const thisTemplater = this.tagSupport.templater;\n        const global = thisTemplater.global;\n        global.insertBefore = insertBefore;\n        if (!global.placeholder) {\n            setTagPlaceholder(global);\n        }\n        const placeholderElm = global.placeholder;\n        global.oldest = this;\n        global.newest = this;\n        subject.tag = this;\n        this.hasLiveElements = true;\n        // remove old clones\n        if (this.clones.length) {\n            this.clones.forEach(clone => this.checkCloneRemoval(clone, 0));\n        }\n        global.insertBefore = insertBefore;\n        // const context = this.tagSupport.memory.context // this.update()\n        const context = this.update();\n        const template = this.getTemplate();\n        const elementContainer = document.createElement('div');\n        elementContainer.id = 'tag-temp-holder';\n        // render content with a first child that we can know is our first element\n        elementContainer.innerHTML = `<template id=\"temp-template-tag-wrap\">${template.string}</template>`;\n        // Search/replace innerHTML variables but don't interpolate tag components just yet\n        const { tagComponents } = interpolateElement(elementContainer, context, template, this, // ownerTag,\n        {\n            forceElement: options.forceElement,\n            counts: options.counts\n        });\n        afterInterpolateElement(elementContainer, placeholderElm, this, // ownerTag\n        context, options);\n        // Any tag components that were found should be processed AFTER the owner processes its elements. Avoid double processing of elements attributes like (oninit)=${}\n        let isForceElement = options.forceElement;\n        tagComponents.forEach(tagComponent => {\n            subscribeToTemplate(tagComponent.insertBefore, tagComponent.subject, tagComponent.ownerTag, options.counts, { isForceElement });\n            afterInterpolateElement(elementContainer, tagComponent.insertBefore, tagComponent.ownerTag, // this, // ownerTag\n            context, options);\n        });\n    }\n}\nfunction setTagPlaceholder(global) {\n    const insertBefore = global.insertBefore;\n    const placeholder = global.placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n}\nfunction afterInterpolateElement(container, insertBefore, tag, \n// preClones: Clones,\ncontext, options) {\n    const clones = buildClones(container, insertBefore);\n    if (!clones.length) {\n        return clones;\n    }\n    clones.forEach(clone => afterElmBuild(clone, options, context, tag));\n    tag.clones.push(...clones);\n    return clones;\n}\nfunction getChildTagsToDestroy(childTags, allTags = []) {\n    for (let index = childTags.length - 1; index >= 0; --index) {\n        const cTag = childTags[index];\n        allTags.push(cTag);\n        childTags.splice(index, 1);\n        getChildTagsToDestroy(cTag.childTags, allTags);\n    }\n    return allTags;\n}\nfunction updateContextItem(context, variableName, value) {\n    const subject = context[variableName];\n    const tag = subject.tag;\n    if (tag) {\n        const oldTemp = tag.tagSupport.templater;\n        if (value && value.global !== oldTemp.global) {\n            if (isTagComponent(value)) {\n                shareTemplaterGlobal(oldTemp, value);\n            }\n        }\n    }\n    // return updateExistingValue(subject, value, this)\n    if (isSubjectInstance(value)) {\n        return;\n    }\n    subject.set(value); // listeners will evaluate updated values to possibly update display(s)\n    return;\n}\nfunction shareTemplaterGlobal(oldTemp, value) {\n    const oldWrap = oldTemp.wrapper; // tag versus component\n    const oldValueFn = oldWrap.original;\n    const newValueFn = value.wrapper?.original;\n    const fnMatched = oldValueFn === newValueFn;\n    if (fnMatched) {\n        value.global = oldTemp.global;\n    }\n}\n","import { deepClone } from './deepFunctions';\nimport { isTagArray, isTagComponent, isTagInstance } from './isInstance';\nexport class BaseTagSupport {\n    templater;\n    subject;\n    isApp = true;\n    propsConfig;\n    memory = {\n        // context: {}, // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n        state: {\n            newest: [],\n        },\n    };\n    constructor(templater, subject) {\n        this.templater = templater;\n        this.subject = subject;\n        const children = this.templater.children; // children tags passed in as arguments\n        const props = this.templater.props; // natural props\n        const latestCloned = deepClone(props);\n        this.propsConfig = {\n            latest: props,\n            latestCloned, // assume its HTML children and then detect\n            clonedProps: latestCloned, // maybe duplicate\n            lastClonedKidValues: children.value.map(kid => {\n                const cloneValues = cloneValueArray(kid.values);\n                return cloneValues;\n            })\n        };\n        // if the latest props are not HTML children, then clone the props for later render cycles to compare\n        if (!isTagInstance(props)) {\n            this.propsConfig.latestCloned = deepClone(latestCloned);\n            this.propsConfig.clonedProps = this.propsConfig.latestCloned;\n        }\n    }\n}\nfunction cloneValueArray(values) {\n    return values.map((value) => {\n        const tag = value;\n        if (isTagInstance(tag)) {\n            return cloneValueArray(tag.values);\n        }\n        if (isTagComponent(tag)) {\n            const tagComponent = tag;\n            return deepClone(tagComponent.props);\n        }\n        if (isTagArray(tag)) {\n            return cloneValueArray(tag);\n        }\n        return deepClone(value);\n    });\n}\nexport class TagSupport extends BaseTagSupport {\n    ownerTagSupport;\n    templater;\n    subject;\n    isApp = false;\n    constructor(ownerTagSupport, templater, subject) {\n        super(templater, subject);\n        this.ownerTagSupport = ownerTagSupport;\n        this.templater = templater;\n        this.subject = subject;\n    }\n}\n","import { runAfterRender, runBeforeRedraw, runBeforeRender } from './tagRunner';\nimport { setUse } from './state';\nimport { isLikeTags } from './isLikeTags.function';\nimport { destroyTagMemory } from './destroyTag.function';\nexport class TemplaterResult {\n    props;\n    children;\n    isTag = false; // when true, is basic tag non-component\n    tagged;\n    wrapper;\n    global = {\n        newestTemplater: this,\n        context: {}, // populated after reading interpolated.values array converted to an object {variable0, variable:1}\n        providers: [],\n        /** Indicator of re-rending. Saves from double rending something already rendered */\n        renderCount: 0,\n        deleted: false,\n        subscriptions: []\n    };\n    tagSupport;\n    constructor(props, children) {\n        this.props = props;\n        this.children = children;\n    }\n    /*\n    redraw?: (\n      force?: boolean, // force children to redraw\n    ) => Tag\n    */\n    isTemplater = true;\n}\nexport function renderWithSupport(tagSupport, existingTag, subject, ownerTag) {\n    const wrapTagSupport = tagSupport; // this.tagSupport\n    /* BEFORE RENDER */\n    const runtimeOwnerTag = existingTag?.ownerTag || ownerTag;\n    if (existingTag) {\n        wrapTagSupport.memory.state.newest = [...existingTag.tagSupport.memory.state.newest];\n        wrapTagSupport.templater.global = existingTag.tagSupport.templater.global;\n        runBeforeRedraw(wrapTagSupport, existingTag);\n    }\n    else {\n        // first time render\n        runBeforeRender(wrapTagSupport, runtimeOwnerTag);\n        // TODO: Logic below most likely could live within providers.ts inside the runBeforeRender function\n        const providers = setUse.memory.providerConfig;\n        providers.ownerTag = runtimeOwnerTag;\n    }\n    /* END: BEFORE RENDER */\n    const templater = wrapTagSupport.templater;\n    // NEW TAG CREATED HERE\n    const retag = templater.wrapper(wrapTagSupport, subject);\n    /* AFTER */\n    runAfterRender(wrapTagSupport, retag);\n    const isLikeTag = !existingTag || isLikeTags(existingTag, retag);\n    if (!isLikeTag) {\n        destroyUnlikeTags(existingTag, templater, subject);\n    }\n    retag.ownerTag = runtimeOwnerTag;\n    wrapTagSupport.templater.global.newest = retag;\n    return retag;\n}\nfunction destroyUnlikeTags(existingTag, // old\ntemplater, // new\nsubject) {\n    const oldGlobal = existingTag.tagSupport.templater.global;\n    const insertBefore = oldGlobal.insertBefore;\n    destroyTagMemory(existingTag, subject);\n    // ??? - new so that when a tag is destroy the unlike does not carry the destroy signifier\n    templater.global = { ...templater.global }; // break memory references\n    const global = templater.global;\n    global.insertBefore = insertBefore;\n    global.deleted = false;\n    delete global.oldest;\n    delete global.newest;\n    delete subject.tag;\n}\n","import { isTagInstance } from './isInstance';\nimport { renderTagSupport } from './renderTagSupport.function';\n/* Used to rewrite props that are functions. When they are called it should cause parent rendering */\nexport function alterProps(props, ownerSupport) {\n    function callback(toCall, callWith) {\n        return callbackPropOwner(toCall, callWith, ownerSupport);\n    }\n    const isPropTag = isTagInstance(props);\n    const watchProps = isPropTag ? 0 : props;\n    const newProps = resetFunctionProps(watchProps, callback);\n    return newProps;\n}\nfunction resetFunctionProps(props, callback) {\n    if (typeof (props) !== 'object') {\n        return props;\n    }\n    const newProps = props;\n    // BELOW: Do not clone because if first argument is object, the memory ref back is lost\n    // const newProps = {...props} \n    Object.entries(newProps).forEach(([name, value]) => {\n        if (value instanceof Function) {\n            const original = newProps[name].original;\n            if (original) {\n                return; // already previously converted\n            }\n            newProps[name] = (...args) => {\n                return newProps[name].toCall(...args); // what gets called can switch over parent state changes\n            };\n            // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n            newProps[name].toCall = (...args) => callback(value, args);\n            newProps[name].original = value;\n            return;\n        }\n    });\n    return newProps;\n}\nexport function callbackPropOwner(toCall, callWith, ownerSupport) {\n    const callbackResult = toCall(...callWith);\n    const lastestOwner = ownerSupport.templater.global.newest;\n    renderTagSupport(lastestOwner.tagSupport, true);\n    return callbackResult;\n}\n","/** File largely responsible for reacting to element events, such as onclick */\nimport { renderTagSupport } from \"./renderTagSupport.function\";\nexport function bindSubjectCallback(value, tag) {\n    // Is this children? No override needed\n    if (value.isChildOverride) {\n        return value;\n    }\n    const subjectFunction = (element, args) => runTagCallback(value, tag, element, args);\n    // link back to original. Mostly used for <div oninit ondestroy> animations\n    subjectFunction.tagFunction = value;\n    return subjectFunction;\n}\nexport function runTagCallback(value, tag, bindTo, args) {\n    const tagSupport = tag.tagSupport;\n    const renderCount = tagSupport.templater.global.renderCount;\n    const method = value.bind(bindTo);\n    const callbackResult = method(...args);\n    const sameRenderCount = renderCount === tagSupport.templater.global.renderCount;\n    // already rendered OR tag was deleted before event processing\n    if (!sameRenderCount || tagSupport.templater.global.deleted) {\n        if (callbackResult instanceof Promise) {\n            return callbackResult.then(() => {\n                return 'promise-no-data-ever'; // tag was deleted during event processing\n            });\n        }\n        return 'no-data-ever'; // already rendered\n    }\n    renderTagSupport(tagSupport, true);\n    if (callbackResult instanceof Promise) {\n        return callbackResult.then(() => {\n            if (tagSupport.templater.global.deleted) {\n                return 'promise-no-data-ever'; // tag was deleted during event processing\n            }\n            renderTagSupport(tagSupport, true);\n            return 'promise-no-data-ever';\n        });\n    }\n    // Caller always expects a Promise\n    return 'no-data-ever';\n}\n","import { isTagArray, isTagComponent, isTagInstance } from './isInstance';\nimport { isLikeTags } from './isLikeTags.function';\nimport { destroyTagMemory, destroyTagSupportPast } from './destroyTag.function';\nimport { insertAfter } from './insertAfter.function';\nexport function checkDestroyPrevious(subject, // existing.value is the old value\nnewValue, insertBefore) {\n    const arraySubject = subject;\n    const wasArray = arraySubject.lastArray;\n    // no longer an array\n    if (wasArray && !isTagArray(newValue)) {\n        const placeholderElm = arraySubject.placeholder;\n        delete arraySubject.lastArray;\n        delete arraySubject.placeholder;\n        insertAfter(insertBefore, placeholderElm);\n        wasArray.forEach(({ tag }) => destroyArrayTag(tag, { added: 0, removed: 0 }));\n        return 'array';\n    }\n    const tagSubject = subject;\n    const existingTag = tagSubject.tag;\n    // no longer tag or component?\n    if (existingTag) {\n        const isValueTag = isTagInstance(newValue);\n        const isSubjectTag = isTagInstance(subject.value);\n        if (isSubjectTag && isValueTag) {\n            const newTag = newValue;\n            // its a different tag now\n            if (!isLikeTags(newTag, existingTag)) {\n                // put template back down\n                restoreTagMarker(existingTag, insertBefore);\n                destroyTagMemory(existingTag, tagSubject);\n                return 2;\n            }\n            return false;\n        }\n        const isValueTagComponent = isTagComponent(newValue);\n        if (isValueTagComponent) {\n            return false; // its still a tag component\n        }\n        // put template back down\n        restoreTagMarker(existingTag, insertBefore);\n        // destroy old component, value is not a component\n        destroyTagMemory(existingTag, tagSubject);\n        return 'different-tag';\n    }\n    const displaySubject = subject;\n    const hasLastValue = 'lastValue' in displaySubject;\n    const lastValue = displaySubject.lastValue; // TODO: we maybe able to use displaySubject.value and remove concept of lastValue\n    // was simple value but now something bigger\n    if (hasLastValue && lastValue !== newValue) {\n        destroySimpleValue(insertBefore, displaySubject);\n        return 4;\n    }\n    return false;\n}\nexport function destroyArrayTag(tag, counts) {\n    destroyTagSupportPast(tag.tagSupport);\n    tag.destroy({\n        stagger: counts.removed++,\n    });\n}\nfunction destroySimpleValue(insertBefore, // always a template tag\nsubject) {\n    const clone = subject.clone;\n    const parent = clone.parentNode;\n    // 1 put the template back down\n    parent.insertBefore(insertBefore, clone);\n    parent.removeChild(clone);\n    delete subject.clone;\n    delete subject.lastValue;\n}\nexport function restoreTagMarker(existingTag, insertBefore) {\n    const global = existingTag.tagSupport.templater.global;\n    const placeholderElm = global.placeholder;\n    if (placeholderElm) {\n        insertAfter(insertBefore, placeholderElm);\n    }\n}\n","export function deepClone(obj) {\n    return makeDeepClone(obj, new WeakMap());\n}\nfunction makeDeepClone(obj, visited) {\n    // If obj is a primitive type or null, return it directly\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj)) {\n        return visited.get(obj);\n    }\n    // Handle special cases like Date and RegExp\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n    // Create an empty object or array with the same prototype\n    const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n    // Register the cloned object to avoid cyclic references\n    visited.set(obj, clone);\n    // Clone each property or element of the object or array\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            clone[i] = makeDeepClone(obj[i], visited);\n        }\n    }\n    else {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                clone[key] = makeDeepClone(obj[key], visited);\n            }\n        }\n    }\n    return clone;\n}\nexport function deepEqual(obj1, obj2) {\n    return isDeepEqual(obj1, obj2, new WeakMap());\n}\nfunction isDeepEqual(obj1, obj2, visited) {\n    const directEqual = obj1 === obj2;\n    if (directEqual || isSameFunctions(obj1, obj2)) {\n        return true;\n    }\n    // If obj is already visited, return the cloned reference\n    if (visited.has(obj1)) {\n        return true;\n    }\n    if (typeof obj1 === 'object' && typeof obj2 === 'object') {\n        // both are dates and were already determined not the same\n        if (obj1 instanceof Date && obj2 instanceof Date) {\n            return false;\n        }\n        // Register the cloned object to avoid cyclic references\n        visited.set(obj1, 0);\n        // Check if obj1 and obj2 are both arrays\n        if (Array.isArray(obj1) && Array.isArray(obj2)) {\n            return isArrayDeepEqual(obj1, obj2, visited);\n        }\n        else if (Array.isArray(obj1) || Array.isArray(obj2)) {\n            // One is an array, and the other is not\n            return false;\n        }\n        return isObjectDeepEqual(obj1, obj2, visited);\n    }\n    return false;\n}\nfunction isObjectDeepEqual(obj1, obj2, visited) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length === 0 && keys2.length === 0) {\n        return true;\n    }\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const keyFound = keys2.includes(key);\n        if (!keyFound || !isDeepEqual(obj1[key], obj2[key], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isArrayDeepEqual(obj1, obj2, visited) {\n    if (obj1.length !== obj2.length) {\n        return false;\n    }\n    for (let i = 0; i < obj1.length; i++) {\n        if (!isDeepEqual(obj1[i], obj2[i], visited)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isSameFunctions(fn0, fn1) {\n    const bothFunction = fn0 instanceof Function && fn1 instanceof Function;\n    return bothFunction && fn0.toString() === fn1.toString();\n}\n","export function destroyTagMemory(tag, subject) {\n    const oldTagSupport = tag.tagSupport;\n    delete subject.tag;\n    delete oldTagSupport.subject.tag; // TODO: this line maybe not needed\n    // must destroy oldest which is tag with elements on stage\n    const oldest = oldTagSupport.templater.global.oldest;\n    oldest.destroy();\n    destroyTagSupportPast(oldTagSupport);\n    oldTagSupport.templater.global.context = {};\n}\nexport function destroyTagSupportPast(oldTagSupport) {\n    delete oldTagSupport.templater.global.oldest;\n    delete oldTagSupport.templater.global.newest;\n}\n","export function elementDestroyCheck(nextSibling, stagger) {\n    const onDestroyDoubleWrap = nextSibling.ondestroy;\n    if (!onDestroyDoubleWrap) {\n        return;\n    }\n    const onDestroyWrap = onDestroyDoubleWrap.tagFunction;\n    if (!onDestroyWrap) {\n        return;\n    }\n    const onDestroy = onDestroyWrap.tagFunction;\n    if (!onDestroy) {\n        return;\n    }\n    const event = { target: nextSibling, stagger };\n    return onDestroy(event);\n}\n","export function elementInitCheck(nextSibling, counts) {\n    const onInitDoubleWrap = nextSibling.oninit;\n    if (!onInitDoubleWrap) {\n        return counts.added;\n    }\n    const onInitWrap = onInitDoubleWrap.tagFunction;\n    if (!onInitWrap) {\n        return counts.added;\n    }\n    const onInit = onInitWrap.tagFunction;\n    if (!onInit) {\n        return counts.added;\n    }\n    const event = { target: nextSibling, stagger: counts.added };\n    onInit(event);\n    return ++counts.added;\n}\n","export class TagError extends Error {\n    details;\n    constructor(message, errorCode, details = {}) {\n        super(message);\n        this.name = TagError.name;\n        this.details = { ...details, errorCode };\n    }\n}\nexport class ArrayNoKeyError extends TagError {\n    constructor(message, details) {\n        super(message, 'array-no-key-error', details);\n        this.name = ArrayNoKeyError.name;\n    }\n}\nexport class StateMismatchError extends TagError {\n    constructor(message, details) {\n        super(message, 'state-mismatch-error', details);\n        this.name = StateMismatchError.name;\n    }\n}\nexport class SyncCallbackError extends TagError {\n    constructor(message, details) {\n        super(message, 'sync-callback-error', details);\n        this.name = SyncCallbackError.name;\n    }\n}\n","import { deepEqual } from \"./deepFunctions\";\nexport function hasTagSupportChanged(oldTagSupport, newTagSupport, newTemplater) {\n    const latestProps = newTemplater.props; // newTagSupport.propsConfig.latest\n    const pastCloneProps = oldTagSupport.propsConfig.latestCloned;\n    const propsChanged = hasPropChanges(latestProps, pastCloneProps);\n    // if no changes detected, no need to continue to rendering further tags\n    if (propsChanged) {\n        return propsChanged;\n    }\n    const kidsChanged = hasKidsChanged(oldTagSupport, newTagSupport);\n    // we already know props didn't change and if kids didn't either, than don't render\n    return kidsChanged;\n}\nexport function hasPropChanges(props, // natural props\npastCloneProps) {\n    /*\n    const isCommonEqual = props === undefined && props === compareToProps\n    if(isCommonEqual) {\n      return false\n    }\n    */\n    let castedProps = props;\n    let castedPastProps = pastCloneProps;\n    // check all prop functions match\n    if (typeof (props) === 'object') {\n        if (!pastCloneProps) {\n            return 3;\n        }\n        castedProps = { ...props };\n        castedPastProps = { ...(pastCloneProps || {}) };\n        const allFunctionsMatch = Object.entries(castedProps).every(([key, value]) => {\n            let compare = castedPastProps[key];\n            if (!(value instanceof Function)) {\n                return 4; // this will be checked in deepEqual\n            }\n            if (!(compare instanceof Function)) {\n                return false; // its a function now but was not before\n            }\n            // ensure we are comparing apples to apples as function get wrapped\n            if (compare.original) {\n                compare = compare.original;\n            }\n            const original = value.original;\n            if (original) {\n                value = value.original;\n            }\n            if (value.toString() !== compare.toString()) {\n                return false; // both are function but not the same\n            }\n            delete castedProps[key]; // its a function and not needed to be compared\n            delete castedPastProps[key]; // its a function and not needed to be compared\n            return 5;\n        });\n        if (!allFunctionsMatch) {\n            return 6; // a change has been detected by function comparisons\n        }\n    }\n    const isEqual = deepEqual(castedPastProps, castedProps);\n    return isEqual ? false : 7; // if equal then no changes\n}\nexport function hasKidsChanged(oldTagSupport, newTagSupport) {\n    const oldCloneKidValues = oldTagSupport.propsConfig.lastClonedKidValues;\n    const newClonedKidValues = newTagSupport.propsConfig.lastClonedKidValues;\n    const everySame = oldCloneKidValues.every((set, index) => {\n        const x = newClonedKidValues[index];\n        return set.every((item, index) => item === x[index]);\n    });\n    return everySame ? false : 9;\n}\n","import { Tag } from \"./Tag.class\";\nexport function html(strings, ...values) {\n    return new Tag(strings, values);\n}\n","// import { redrawTag } from \"./redrawTag.function\"\nimport { tagElement } from \"./tagElement\";\nexport * from \"./ElementTargetEvent.interface\";\nexport * from \"./tag\";\nexport * from \"./html\";\nexport * from \"./errors\";\nexport * from \"./subject/index\";\nexport * from \"./isInstance\";\nexport * from \"./state/index\";\nexport * from \"./TagSupport.class\";\n// export * from \"./redrawTag.function\"\nexport * from \"./interpolateElement\";\n// TODO: export *\nexport { tagElement } from \"./tagElement\";\nexport { Tag } from \"./Tag.class\";\nexport { runBeforeRender } from \"./tagRunner\";\nexport { renderTagSupport } from \"./renderTagSupport.function\";\nexport const hmr = {\n    tagElement,\n    // redrawTag\n};\n","export function inputAttribute(name, value, element) {\n    const names = name.split('.');\n    // style.position = \"absolute\"\n    if (names[0] === 'style') {\n        element.style[names[1]] = value;\n    }\n    // Example: class.width-full = \"true\"\n    if (names[0] === 'class') {\n        names.shift();\n        if (value) {\n            names.forEach(name => element.classList.add(name));\n        }\n        else {\n            names.forEach(name => element.classList.remove(name));\n        }\n        return;\n    }\n}\n","// Function to insert element after reference element\nexport function insertAfter(newNode, referenceNode) {\n    const parentNode = referenceNode.parentNode;\n    parentNode.insertBefore(newNode, referenceNode.nextSibling);\n}\n","import { processAttribute } from \"./processAttribute.function\";\nfunction howToSetAttribute(element, name, value) {\n    element.setAttribute(name, value);\n}\nfunction howToSetInputValue(element, name, value) {\n    element[name] = value;\n}\nexport function interpolateAttributes(child, scope, ownerTag) {\n    const attrNames = child.getAttributeNames();\n    let howToSet = howToSetAttribute;\n    attrNames.forEach(attrName => {\n        if (child.nodeName === 'INPUT' && attrName === 'value') {\n            howToSet = howToSetInputValue;\n        }\n        const value = child.getAttribute(attrName);\n        processAttribute(attrName, value, child, scope, ownerTag, howToSet);\n        howToSet = howToSetAttribute; // put back\n    });\n}\n","import { interpolateTemplate } from \"./interpolateTemplate\";\nexport function interpolateContentTemplates(element, context, tag, options, children) {\n    if (!children || element.tagName === 'TEMPLATE') {\n        return { clones: [], tagComponents: [] }; // done\n    }\n    // counting for animation stagger computing\n    const counts = options.counts;\n    const clones = [];\n    const tagComponents = [];\n    const childArray = new Array(...children);\n    childArray.forEach(child => {\n        const { clones: nextClones, tagComponent } = interpolateTemplate(child, context, tag, counts, options);\n        clones.push(...nextClones);\n        if (tagComponent) {\n            tagComponents.push(tagComponent);\n            return;\n        }\n        if (child.children) {\n            const nextKids = new Array(...child.children);\n            nextKids.forEach((subChild, index) => {\n                // IF <template end /> its a variable to be processed\n                if (isRenderEndTemplate(subChild)) {\n                    const { tagComponent } = interpolateTemplate(subChild, context, tag, counts, options);\n                    if (tagComponent) {\n                        tagComponents.push(tagComponent);\n                    }\n                }\n                const { clones: nextClones, tagComponents: nextTagComponent } = interpolateContentTemplates(subChild, context, tag, options, subChild.children);\n                clones.push(...nextClones);\n                tagComponents.push(...nextTagComponent);\n            });\n        }\n    });\n    return { clones, tagComponents };\n}\nfunction isRenderEndTemplate(child) {\n    const isTemplate = child.tagName === 'TEMPLATE';\n    return isTemplate &&\n        child.getAttribute('interpolate') !== undefined &&\n        child.getAttribute('end') !== undefined;\n}\n","import { interpolateAttributes } from \"./interpolateAttributes\";\nimport { interpolateToTemplates } from \"./interpolations\";\nimport { interpolateContentTemplates } from \"./interpolateContentTemplates\";\nimport { escapeSearch, variablePrefix } from \"./Tag.class\";\n/** Review elements within an element */\nexport function interpolateElement(container, // element containing innerHTML to review interpolations\ncontext, // variables used to evaluate\ninterpolatedTemplates, tagOwner, options) {\n    const clones = [];\n    const tagComponents = [];\n    const result = interpolatedTemplates.interpolation;\n    const template = container.children[0];\n    const children = template.content.children;\n    if (result.keys.length) {\n        const { clones: nextClones, tagComponents: nextTagComponents } = interpolateContentTemplates(container, context, tagOwner, options, children);\n        clones.push(...nextClones);\n        tagComponents.push(...nextTagComponents);\n    }\n    interpolateAttributes(container, context, tagOwner);\n    processChildrenAttributes(children, context, tagOwner);\n    return { clones, tagComponents };\n}\nfunction processChildrenAttributes(children, context, ownerTag) {\n    new Array(...children).forEach(child => {\n        interpolateAttributes(child, context, ownerTag);\n        if (child.children) {\n            processChildrenAttributes(child.children, context, ownerTag);\n        }\n    });\n}\nexport function interpolateString(string) {\n    const result = interpolateToTemplates(string);\n    result.string = result.string.replace(escapeSearch, variablePrefix);\n    return result;\n}\n","import { variablePrefix } from \"./Tag.class\";\nimport { elementInitCheck } from \"./elementInitCheck\";\nimport { processSubjectValue } from \"./processSubjectValue.function\";\nimport { isTagArray, isTagComponent } from \"./isInstance\";\nimport { scanTextAreaValue } from \"./scanTextAreaValue.function\";\nimport { updateExistingValue } from \"./updateExistingValue.function\";\nexport function interpolateTemplate(insertBefore, // <template end interpolate /> (will be removed)\ncontext, // variable scope of {`__tagvar${index}`:'x'}\nownerTag, // Tag class\ncounts, // used for animation stagger computing\noptions) {\n    // TODO: THe clones array is useless here\n    const clones = [];\n    if (!insertBefore.hasAttribute('end')) {\n        return { clones }; // only care about <template end>\n    }\n    const variableName = insertBefore.getAttribute('id');\n    if (variableName?.substring(0, variablePrefix.length) !== variablePrefix) {\n        return { clones }; // ignore, not a tagVar\n    }\n    const existingSubject = context[variableName];\n    const isDynamic = isTagComponent(existingSubject.value) || isTagArray(existingSubject.value);\n    // process dynamics later\n    if (isDynamic) {\n        return {\n            clones,\n            tagComponent: {\n                variableName,\n                ownerTag,\n                subject: existingSubject,\n                insertBefore\n            }\n        };\n    }\n    let isForceElement = options.forceElement;\n    subscribeToTemplate(insertBefore, existingSubject, ownerTag, counts, { isForceElement });\n    return { clones };\n}\nexport function subscribeToTemplate(insertBefore, subject, ownerTag, counts, // used for animation stagger computing\n{ isForceElement }) {\n    let called = false;\n    const callback = (value) => {\n        // const orgInsert = insertBefore\n        /*\n        const clone = (subject as DisplaySubject).clone\n        if(clone && clone.parentNode) {\n          insertBefore = clone\n        }\n        */\n        if (called) {\n            updateExistingValue(subject, value, ownerTag, insertBefore);\n            return;\n        }\n        processSubjectValue(value, subject, insertBefore, ownerTag, {\n            counts: { ...counts },\n            forceElement: isForceElement,\n        });\n        if (isForceElement) {\n            isForceElement = false; // only can happen once\n        }\n        // ownerTag.clones.push(...clones)\n        // ownerTag.clones.push(...nextClones)\n        // clones.push(...nextClones)\n        called = true;\n    };\n    const sub = subject.subscribe(callback);\n    ownerTag.tagSupport.templater.global.subscriptions.push(sub);\n}\nexport function afterElmBuild(elm, options, context, ownerTag) {\n    if (!elm.getAttribute) {\n        return;\n    }\n    const tagName = elm.nodeName; // elm.tagName\n    if (tagName === 'TEXTAREA') {\n        scanTextAreaValue(elm, context, ownerTag);\n    }\n    let diff = options.counts.added;\n    diff = elementInitCheck(elm, options.counts) - diff;\n    if (elm.children) {\n        new Array(...elm.children).forEach((child, index) => {\n            const subOptions = {\n                ...options,\n                counts: options.counts,\n            };\n            return afterElmBuild(child, subOptions, context, ownerTag);\n        });\n    }\n}\n","// support arrow functions in attributes\nexport const interpolateReplace = /(?:<[^>]*?(?:(?:\\s+\\w+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)))*\\s*)\\/?>)|({__tagvar[^}]+})/g;\n/** replaces ${x} with <template id=\"x-start\"></template><template id=\"x-end\"></template> */\nexport function interpolateToTemplates(template) {\n    const keys = [];\n    const string = template.replace(interpolateReplace, (match, expression) => {\n        if (match.startsWith('<')) {\n            // If the match is an HTML tag, don't replace\n            return match;\n        }\n        const noBraces = expression.substring(1, expression.length - 1);\n        const id = noBraces;\n        keys.push(id);\n        return `<template interpolate end id=\"${id}\"></template>`;\n    });\n    return { string, keys };\n}\n","export function isTagComponent(value) {\n    return value?.isTemplater === true;\n}\nexport function isTagInstance(tag) {\n    return tag?.isTag === true;\n}\nexport function isSubjectInstance(subject) {\n    return (subject?.isSubject === true || subject?.subscribe) ? true : false; // subject?.isSubject === true || \n}\nexport function isTagArray(value) {\n    return value instanceof Array && value.every(x => isTagInstance(x));\n}\n","export function isLikeTags(tag0, tag1) {\n    if (tag0.strings.length !== tag1.strings.length) {\n        return false;\n    }\n    const everyStringMatched = tag0.strings.every((string, index) => tag1.strings[index] === string);\n    if (!everyStringMatched) {\n        return false;\n    }\n    const valuesLengthsMatch = tag0.values.length === tag1.values.length;\n    if (!valuesLengthsMatch) {\n        return false;\n    }\n    const allVarsMatch = tag1.values.every((value, index) => {\n        const compareTo = tag0.values[index];\n        const isFunctions = value instanceof Function && compareTo instanceof Function;\n        if (isFunctions) {\n            const stringMatch = value.toString() === compareTo.toString();\n            if (stringMatch) {\n                return true;\n            }\n            return false;\n        }\n        return true; // deepEqual(value, compareTo)\n    });\n    if (allVarsMatch) {\n        return true;\n    }\n    return false;\n}\n","import { inputAttribute } from './inputAttribute';\nimport { isSubjectInstance } from './isInstance';\nimport { bindSubjectCallback } from './bindSubjectCallback.function';\nconst startRegX = /^\\s*{__tagvar/;\nconst endRegX = /}\\s*$/;\nfunction isTagVar(value) {\n    return value && value.search(startRegX) >= 0 && value.search(endRegX) >= 0;\n}\nexport function processAttribute(attrName, value, child, scope, ownerTag, howToSet) {\n    if (isTagVar(value)) {\n        return processScopedNameValueAttr(attrName, value, child, scope, ownerTag, howToSet);\n    }\n    if (isTagVar(attrName)) {\n        const contextValueSubject = getContextValueByVarString(scope, attrName);\n        let lastValue;\n        // the above callback gets called immediately since its a ValueSubject()\n        const sub = contextValueSubject.subscribe((value) => {\n            processNameOnlyAttr(value, lastValue, child, ownerTag, howToSet);\n            lastValue = value;\n        });\n        ownerTag.tagSupport.templater.global.subscriptions.push(sub); // this is where unsubscribe is picked up\n        child.removeAttribute(attrName);\n        return;\n    }\n    // Non dynamic\n    const isSpecial = isSpecialAttr(attrName);\n    if (isSpecial) {\n        return inputAttribute(attrName, value, child);\n    }\n}\nfunction processScopedNameValueAttr(attrName, value, // {__tagVarN}\nchild, scope, ownerTag, howToSet) {\n    // get the code inside the brackets like \"variable0\" or \"{variable0}\"\n    const result = getContextValueByVarString(scope, value);\n    return processNameValueAttr(attrName, result, child, ownerTag, howToSet);\n}\nfunction getContextValueByVarString(scope, value) {\n    const code = value.replace('{', '').split('').reverse().join('').replace('}', '').split('').reverse().join('');\n    return scope[code];\n}\nfunction processNameOnlyAttr(attrValue, lastValue, child, ownerTag, howToSet) {\n    if (lastValue && lastValue != attrValue) {\n        if (typeof (lastValue) === 'string') {\n            child.removeAttribute(lastValue);\n        }\n        else if (lastValue instanceof Object) {\n            Object.entries(lastValue).forEach(([name]) => child.removeAttribute(name));\n        }\n    }\n    if (typeof (attrValue) === 'string') {\n        if (!attrValue.length) {\n            return;\n        }\n        processNameValueAttr(attrValue, '', child, ownerTag, howToSet);\n        return;\n    }\n    if (attrValue instanceof Object) {\n        Object.entries(attrValue).forEach(([name, value]) => processNameValueAttr(name, value, child, ownerTag, howToSet));\n        return;\n    }\n}\nfunction processNameValueAttr(attrName, result, child, ownerTag, howToSet) {\n    const isSpecial = isSpecialAttr(attrName);\n    // attach as callback?\n    if (result instanceof Function) {\n        const action = function (...args) {\n            const result2 = result(child, args);\n            return result2;\n        };\n        child[attrName].action = action;\n        // child.addEventListener(attrName, action)\n    }\n    // Most every variable comes in here since everything is made a ValueSubject\n    if (isSubjectInstance(result)) {\n        child.removeAttribute(attrName);\n        const callback = (newAttrValue) => {\n            if (newAttrValue instanceof Function) {\n                newAttrValue = bindSubjectCallback(newAttrValue, ownerTag);\n            }\n            return processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet);\n        };\n        // 🗞️ Subscribe. Above callback called immediately since its a ValueSubject()\n        const sub = result.subscribe(callback);\n        // Record subscription for later unsubscribe when element destroyed\n        ownerTag.tagSupport.templater.global.subscriptions.push(sub);\n        return;\n    }\n    howToSet(child, attrName, result);\n    // child.setAttribute(attrName, result.value)\n    return;\n}\nfunction processAttributeSubjectValue(newAttrValue, child, attrName, isSpecial, howToSet) {\n    if (newAttrValue instanceof Function) {\n        const fun = function (...args) {\n            return newAttrValue(child, args);\n        };\n        // access to original function\n        fun.tagFunction = newAttrValue;\n        child[attrName] = fun;\n        return;\n    }\n    if (isSpecial) {\n        inputAttribute(attrName, newAttrValue, child);\n        return;\n    }\n    if (newAttrValue) {\n        howToSet(child, attrName, newAttrValue);\n        return;\n    }\n    const isDeadValue = [undefined, false, null].includes(newAttrValue);\n    if (isDeadValue) {\n        child.removeAttribute(attrName);\n        return;\n    }\n    // value is 0\n    howToSet(child, attrName, newAttrValue);\n}\n/** Looking for (class | style) followed by a period */\nfunction isSpecialAttr(attrName) {\n    return attrName.search(/^(class|style)(\\.)/) >= 0;\n}\n","import { ValueSubject } from './subject/ValueSubject';\nimport { isSubjectInstance, isTagComponent, isTagInstance } from './isInstance';\nexport function processNewValue(hasValue, value, ownerTag) {\n    if (isTagComponent(value)) {\n        const tagSubject = new ValueSubject(value);\n        return tagSubject;\n    }\n    if (value instanceof Function) {\n        // return getSubjectFunction(value, ownerTag)\n        return new ValueSubject(value);\n    }\n    if (!hasValue) {\n        return; // more strings than values, stop here\n    }\n    if (isTagInstance(value)) {\n        value.ownerTag = ownerTag;\n        return new ValueSubject(value);\n    }\n    if (isSubjectInstance(value)) {\n        return value; // its already a value subject\n    }\n    return new ValueSubject(value);\n}\n","import { updateBeforeTemplate } from './updateBeforeTemplate.function';\nexport function processRegularValue(value, subject, // could be tag via subject.tag\ninsertBefore) {\n    subject.insertBefore = insertBefore;\n    const before = subject.clone || insertBefore; // Either the template is on the doc OR its the first element we last put on doc\n    // matches but also was defined at some point\n    if (subject.lastValue === value && 'lastValue' in subject) {\n        return; // no need to update display, its the same\n    }\n    subject.lastValue = value;\n    // Processing of regular values\n    const clone = updateBeforeTemplate(value, before);\n    subject.clone = clone; // remember single element put down, for future updates\n}\n","import { renderWithSupport } from './TemplaterResult.class';\nimport { setUse } from './state';\nimport { processTagResult } from './processTagResult.function';\nimport { TagSupport } from './TagSupport.class';\nexport function processSubjectComponent(templater, subject, insertBefore, ownerTag, options) {\n    // Check if function component is wrapped in a tag() call\n    // TODO: This below check not needed in production mode\n    if (templater.tagged !== true) {\n        const original = templater.wrapper.original;\n        let name = original.name || original.constructor?.name;\n        if (name === 'Function') {\n            name = undefined;\n        }\n        const label = name || original.toString().substring(0, 120);\n        const error = new Error(`Not a tag component. Wrap your function with tag(). Example tag(props => html\\`\\`) on component:\\n\\n${label}\\n\\n`);\n        throw error;\n    }\n    templater.tagSupport = new TagSupport(ownerTag.tagSupport, templater, subject);\n    templater.global.insertBefore = insertBefore;\n    let retag = subject.tag;\n    const providers = setUse.memory.providerConfig;\n    providers.ownerTag = ownerTag;\n    const isRedraw = !retag || options.forceElement;\n    if (isRedraw) {\n        retag = redrawSubjectComponent(templater, subject, retag, ownerTag, insertBefore);\n    }\n    processTagResult(retag, subject, // The element set here will be removed from document. Also result.tag will be added in here\n    insertBefore, // <template end interpolate /> (will be removed)\n    options);\n    return retag;\n}\nfunction redrawSubjectComponent(templater, subject, retag, ownerTag, insertBefore) {\n    const preClones = ownerTag.clones.map(clone => clone);\n    retag = renderWithSupport(templater.tagSupport, subject.tag, // existing tag\n    subject, ownerTag);\n    templater.global.newest = retag;\n    if (ownerTag.clones.length > preClones.length) {\n        const myClones = ownerTag.clones.filter(fClone => !preClones.find(clone => clone === fClone));\n        retag.clones.push(...myClones);\n    }\n    ownerTag.childTags.push(retag);\n    return retag;\n}\n","import { processSubjectComponent } from './processSubjectComponent.function';\nimport { isTagArray, isTagComponent, isTagInstance } from './isInstance';\nimport { processTagArray } from './processTagArray';\nimport { processRegularValue } from './processRegularValue.function';\nimport { processTag } from './processTag.function';\nvar ValueTypes;\n(function (ValueTypes) {\n    ValueTypes[\"tag\"] = \"tag\";\n    ValueTypes[\"tagArray\"] = \"tag-array\";\n    ValueTypes[\"tagComponent\"] = \"tag-component\";\n    ValueTypes[\"value\"] = \"value\";\n})(ValueTypes || (ValueTypes = {}));\nfunction getValueType(value) {\n    if (isTagComponent(value)) {\n        return ValueTypes.tagComponent;\n    }\n    if (isTagInstance(value)) {\n        return ValueTypes.tag;\n    }\n    if (isTagArray(value)) {\n        return ValueTypes.tagArray;\n    }\n    return ValueTypes.value;\n}\nexport function processSubjectValue(value, subject, // could be tag via result.tag\ninsertBefore, // <template end interpolate /> (will be removed)\nownerTag, // owner\noptions) {\n    const valueType = getValueType(value);\n    switch (valueType) {\n        case ValueTypes.tag:\n            processTag(value, subject, insertBefore, ownerTag);\n            return;\n        case ValueTypes.tagArray:\n            return processTagArray(subject, value, insertBefore, ownerTag, options);\n        case ValueTypes.tagComponent:\n            processSubjectComponent(value, subject, insertBefore, ownerTag, options);\n            return;\n    }\n    processRegularValue(value, subject, insertBefore);\n}\n","import { TagSupport } from './TagSupport.class';\nimport { ValueSubject } from './subject';\n/** Could be a regular tag or a component. Both are Tag.class */\nexport function processTag(tag, subject, // could be tag via result.tag\ninsertBefore, ownerTag) {\n    // first time seeing this tag?\n    if (!tag.tagSupport) {\n        applyFakeTemplater(tag, ownerTag, subject);\n        ownerTag.childTags.push(tag);\n    }\n    tag.ownerTag = ownerTag;\n    tag.buildBeforeElement(insertBefore, {\n        counts: { added: 0, removed: 0 },\n        forceElement: true,\n    });\n}\nexport function applyFakeTemplater(tag, ownerTag, subject) {\n    const fakeTemplater = getFakeTemplater();\n    tag.tagSupport = new TagSupport(ownerTag.tagSupport, fakeTemplater, // the template is provided via html`` call\n    subject);\n    fakeTemplater.global.oldest = tag;\n    fakeTemplater.global.newest = tag;\n    fakeTemplater.tagSupport = tag.tagSupport;\n    // asking me to render will cause my parent to render\n    tag.ownerTag = ownerTag;\n}\nfunction getFakeTemplater() {\n    return {\n        global: {\n            renderCount: 0,\n            providers: [],\n            context: {},\n            subscriptions: [],\n            deleted: false,\n            newestTemplater: {},\n        },\n        children: new ValueSubject([]), // no children\n        props: {},\n        isTag: true,\n        isTemplater: false,\n        tagged: false,\n        wrapper: (() => undefined),\n        tagSupport: {},\n    };\n}\n","import { ValueSubject } from './subject/ValueSubject';\nimport { ArrayNoKeyError } from './errors';\nimport { destroyArrayTag } from './checkDestroyPrevious.function';\nimport { applyFakeTemplater } from './processTag.function';\nexport function processTagArray(subject, value, // arry of Tag classes\ninsertBefore, // <template end interpolate />\nownerTag, options) {\n    const clones = ownerTag.clones; // []\n    let lastArray = subject.lastArray = subject.lastArray || [];\n    if (!subject.placeholder) {\n        setPlaceholderElm(insertBefore, subject);\n    }\n    const runtimeInsertBefore = subject.placeholder; // || insertBefore\n    let removed = 0;\n    /** 🗑️ remove previous items first */\n    lastArray = subject.lastArray = subject.lastArray.filter((item, index) => {\n        const newLength = value.length - 1;\n        const at = index - removed;\n        const lessLength = newLength < at;\n        const subTag = value[index - removed];\n        const subArrayValue = subTag?.memory.arrayValue;\n        const tag = item.tag;\n        const destroyItem = lessLength || !areLikeValues(subArrayValue, tag.memory.arrayValue);\n        if (destroyItem) {\n            const last = lastArray[index];\n            const tag = last.tag;\n            destroyArrayTag(tag, options.counts);\n            last.deleted = true;\n            ++removed;\n            ++options.counts.removed;\n            return false;\n        }\n        return true;\n    });\n    value.forEach((subTag, index) => {\n        const previous = lastArray[index];\n        const previousSupport = previous?.tag.tagSupport;\n        const fakeSubject = new ValueSubject({});\n        applyFakeTemplater(subTag, ownerTag, fakeSubject);\n        if (previousSupport) {\n            subTag.tagSupport.templater.global = previousSupport.templater.global;\n            previousSupport.templater.global.newest = subTag;\n        }\n        // check for html``.key()\n        const keySet = 'arrayValue' in subTag.memory;\n        if (!keySet) {\n            const details = {\n                template: subTag.getTemplate().string,\n                array: value,\n                ownerTagContent: ownerTag.lastTemplateString,\n            };\n            const message = 'Use html`...`.key(item) instead of html`...` to template an Array';\n            console.error(message, details);\n            const err = new ArrayNoKeyError(message, details);\n            throw err;\n        }\n        const couldBeSame = lastArray.length > index;\n        if (couldBeSame) {\n            const prevSupport = previous.tag.tagSupport;\n            const prevGlobal = prevSupport.templater.global;\n            /*\n            const isSame = areLikeValues(\n              previous.tag.memory.arrayValue,\n              subTag.memory.arrayValue,\n            )\n            */\n            subTag.tagSupport = subTag.tagSupport || prevSupport;\n            const oldest = prevGlobal.oldest;\n            oldest.updateByTag(subTag);\n            return [];\n        }\n        processAddTagArrayItem(runtimeInsertBefore, subTag, index, options, lastArray);\n        ownerTag.childTags.push(subTag);\n    });\n    return clones;\n}\nfunction setPlaceholderElm(insertBefore, subject) {\n    if (insertBefore.nodeName !== 'TEMPLATE') {\n        subject.placeholder = insertBefore;\n        return;\n    }\n    const placeholder = subject.placeholder = document.createTextNode('');\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(placeholder, insertBefore);\n    parentNode.removeChild(insertBefore);\n}\nfunction processAddTagArrayItem(before, subTag, index, options, lastArray) {\n    const lastValue = {\n        tag: subTag, index\n    };\n    // Added to previous array\n    lastArray.push(lastValue);\n    const counts = {\n        added: options.counts.added + index,\n        removed: options.counts.removed,\n    };\n    const newTempElm = document.createElement('template');\n    const parent = before.parentNode;\n    parent.insertBefore(newTempElm, before);\n    subTag.buildBeforeElement(newTempElm, // before,\n    { counts, forceElement: options.forceElement });\n}\n/** compare two values. If both values are arrays then the items will be compared */\nfunction areLikeValues(valueA, valueB) {\n    if (valueA === valueB) {\n        return true;\n    }\n    const bothArrays = valueA instanceof Array && valueB instanceof Array;\n    const matchLengths = bothArrays && valueA.length == valueB.length;\n    if (matchLengths) {\n        return valueA.every((item, index) => item == valueB[index]);\n    }\n    return false;\n}\n","export function processTagResult(tag, subject, // used for recording past and current value\ninsertBefore, // <template end interpolate />\n{ counts, forceElement, }) {\n    // *if appears we already have seen\n    const subjectTag = subject;\n    const existingTag = subjectTag.tag;\n    const previousTag = existingTag?.tagSupport.templater.global.oldest || undefined; // || tag.tagSupport.oldest // subjectTag.tag\n    const justUpdate = previousTag; // && !forceElement\n    if (previousTag && justUpdate) {\n        /*\n        const areLike = previousTag.isLikeTag(tag)\n    \n        // are we just updating an if we already had?\n        if(areLike) {\n          return processTagResultUpdate(tag, subjectTag, previousTag)\n        }\n        */\n        return processTagResultUpdate(tag, subjectTag, previousTag);\n    }\n    tag.buildBeforeElement(insertBefore, {\n        counts,\n        forceElement,\n    });\n}\nfunction processTagResultUpdate(tag, subject, // used for recording past and current value\npreviousTag) {\n    // components\n    if (subject instanceof Function) {\n        const newTag = subject(previousTag.tagSupport);\n        previousTag.updateByTag(newTag);\n        subject.tag = newTag;\n        return;\n    }\n    previousTag.updateByTag(tag);\n    subject.tag = tag;\n    return;\n}\n","export function buildClones(temporary, insertBefore) {\n    const clones = [];\n    const template = temporary.children[0];\n    let nextSibling = template.content.firstChild;\n    while (nextSibling) {\n        const nextNextSibling = nextSibling.nextSibling;\n        buildSibling(nextSibling, insertBefore);\n        clones.push(nextSibling);\n        nextSibling = nextNextSibling;\n    }\n    return clones;\n}\nfunction buildSibling(nextSibling, insertBefore) {\n    const parentNode = insertBefore.parentNode;\n    parentNode.insertBefore(nextSibling, insertBefore);\n}\n","import { providersChangeCheck } from './state/provider.utils';\nimport { renderWithSupport } from './TemplaterResult.class';\nimport { isLikeTags } from './isLikeTags.function';\n/** Returns true when rendering owner is not needed. Returns false when rendering owner should occur */\nexport function renderExistingTag(oldestTag, // existing tag already there\nnewTemplater, tagSupport, subject) {\n    const tag = subject.tag;\n    newTemplater.global = tag.tagSupport.templater.global;\n    const preRenderCount = tagSupport.templater.global.renderCount;\n    providersChangeCheck(oldestTag);\n    // When the providers were checked, a render to myself occurred and I do not need to re-render again\n    const latestTag = tagSupport.templater.global.newest;\n    if (preRenderCount !== tagSupport.templater.global.renderCount) {\n        oldestTag.updateByTag(latestTag);\n        return latestTag;\n    }\n    const oldTemplater = tagSupport.templater || newTemplater;\n    const toRedrawTag = subject.tag || oldTemplater.global.newest || oldTemplater.global.oldest; // hmmmmmm, why not newest?\n    const redraw = renderWithSupport(newTemplater.tagSupport, toRedrawTag, subject, oldestTag.ownerTag);\n    const oldest = tagSupport.templater.global.oldest || oldestTag;\n    redraw.tagSupport.templater.global.oldest = oldest;\n    if (isLikeTags(latestTag, redraw)) {\n        subject.tag = redraw;\n        oldest.updateByTag(redraw);\n    }\n    return redraw;\n}\n","import { deepEqual } from './deepFunctions';\nimport { isTagInstance } from './isInstance';\nimport { renderExistingTag } from './renderExistingTag.function';\n/** Main function used by all other callers to render/update display of a tag component */\nexport function renderTagSupport(tagSupport, renderUp) {\n    const global = tagSupport.templater.global;\n    if (isTagInstance(tagSupport.templater)) {\n        const newTag = global.newest;\n        const ownerTag = newTag.ownerTag;\n        ++global.renderCount;\n        return renderTagSupport(ownerTag.tagSupport, true);\n    }\n    // const oldTagSetup = this\n    const subject = tagSupport.subject;\n    const templater = tagSupport.templater; // oldTagSetup.templater // templater\n    const subjectTag = subject.tag;\n    const newest = subjectTag?.tagSupport.templater.global.newest;\n    let ownerTag;\n    let selfPropChange = false;\n    const shouldRenderUp = renderUp && newest;\n    if (shouldRenderUp) {\n        ownerTag = newest.ownerTag;\n        if (ownerTag) {\n            const nowProps = templater.props;\n            const latestProps = newest.tagSupport.propsConfig.latestCloned;\n            selfPropChange = !deepEqual(nowProps, latestProps);\n        }\n    }\n    const useTagSupport = global.newest?.tagSupport; // oldTagSetup\n    const tag = renderExistingTag(templater.global.oldest, templater, useTagSupport, subject);\n    const renderOwner = ownerTag && selfPropChange;\n    if (renderOwner) {\n        const ownerTagSupport = ownerTag.tagSupport;\n        renderTagSupport(ownerTagSupport, true);\n        return tag;\n    }\n    return tag;\n}\n","import { processAttribute } from './processAttribute.function';\nconst search = new RegExp('\\\\s*<template interpolate end id=\"__tagvar(\\\\d{1,4})\"([^>]*)></template>(\\\\s*)');\nexport function scanTextAreaValue(textarea, context, ownerTag) {\n    const value = textarea.value;\n    if (value.search(search) >= 0) {\n        const match = value.match(/__tagvar(\\d{1,4})/);\n        const token = match ? match[0] : '';\n        const dynamic = '{' + token + '}';\n        textarea.value = '';\n        textarea.setAttribute('text-var-value', dynamic);\n        const howToSet = (_elm, _name, value) => textarea.value = value;\n        processAttribute('text-var-value', dynamic, // realValue, // context[token].value,\n        textarea, context, ownerTag, howToSet);\n    }\n}\n","import { setUse } from \"./setUse.function\";\nimport { getStateValue } from \"./state.utils\";\nimport { renderTagSupport } from \"../renderTagSupport.function\";\nimport { SyncCallbackError } from \"../errors\";\nlet innerCallback = (callback) => (a, b, c, d, e, f) => {\n    throw new SyncCallbackError('Callback function was called immediately in sync and must instead be call async');\n};\nexport const callbackMaker = () => innerCallback;\nconst originalGetter = innerCallback; // callbackMaker\nsetUse({\n    beforeRender: (tagSupport) => initMemory(tagSupport),\n    beforeRedraw: (tagSupport) => initMemory(tagSupport),\n    afterRender: (_tagSupport) => {\n        innerCallback = originalGetter; // prevent crossing callbacks with another tag\n    },\n});\nfunction updateState(stateFrom, stateTo) {\n    stateFrom.forEach((state, index) => {\n        const fromValue = getStateValue(state);\n        const callback = stateTo[index].callback;\n        if (callback) {\n            callback(fromValue); // set the value\n        }\n        stateTo[index].lastValue = fromValue; // record the value\n    });\n}\nfunction initMemory(tagSupport) {\n    const oldState = setUse.memory.stateConfig.array;\n    innerCallback = (callback) => {\n        const trigger = (...args) => triggerStateUpdate(tagSupport, callback, oldState, ...args);\n        return trigger;\n    };\n}\nfunction triggerStateUpdate(tagSupport, callback, oldState, ...args) {\n    const state = tagSupport.memory.state;\n    const newest = state.newest;\n    // ensure that the oldest has the latest values first\n    updateState(newest, oldState);\n    // run the callback\n    const promise = callback(...args);\n    // send the oldest state changes into the newest\n    updateState(oldState, newest);\n    renderTagSupport(tagSupport, false);\n    if (promise instanceof Promise) {\n        promise.finally(() => {\n            // send the oldest state changes into the newest\n            updateState(oldState, newest);\n            renderTagSupport(tagSupport, false);\n        });\n    }\n}\n","export * from \"./watch.function\";\nexport { setUse } from \"./setUse.function\";\nexport { state } from \"./state.function\";\nexport { letState } from \"./letState.function\";\nexport { setProp } from \"./setProp.function\";\nexport { providers } from \"./providers\";\nexport * from \"./callbackMaker.function\";\nexport * from \"./onInit\";\nexport * from \"./onDestroy\";\n","import { getStateValue } from './state.utils';\nimport { setUse } from './setUse.function';\n/** Used for variables that need to remain the same variable during render passes */\nexport function letState(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    const rearray = config.rearray;\n    let getSetMethod;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return makeStateResult(oldValue, push);\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return makeStateResult(initValue, push);\n}\nfunction makeStateResult(initValue, push) {\n    // return initValue\n    const result = (y) => {\n        push.callback = y || (x => [initValue, initValue = x]);\n        return initValue;\n    };\n    return result;\n}\n","import { setUse } from \"./setUse.function\";\n/** When undefined, it means a tag is being built for the first time so do run destroy(s) */\nlet destroyCurrentTagSupport;\nexport function onDestroy(callback) {\n    destroyCurrentTagSupport.templater.global.destroyCallback = callback;\n}\nsetUse({\n    beforeRender: tagSupport => destroyCurrentTagSupport = tagSupport,\n    beforeRedraw: tagSupport => destroyCurrentTagSupport = tagSupport,\n    beforeDestroy: (tagSupport, tag) => {\n        const callback = tagSupport.templater.global.destroyCallback;\n        if (callback) {\n            callback();\n        }\n    }\n});\n","import { setUse } from \"./setUse.function\";\nfunction setCurrentTagSupport(support) {\n    setUse.memory.initCurrentTemplater = support.templater;\n}\nexport function onInit(callback) {\n    const templater = setUse.memory.initCurrentTemplater;\n    if (!templater.global.init) {\n        ;\n        templater.global.init = callback;\n        callback(); // fire init\n    }\n}\nsetUse({\n    beforeRender: tagSupport => setCurrentTagSupport(tagSupport),\n    beforeRedraw: tagSupport => setCurrentTagSupport(tagSupport),\n});\n","import { deepClone, deepEqual } from '../deepFunctions';\nimport { renderTagSupport } from '../renderTagSupport.function';\nexport function providersChangeCheck(tag) {\n    const global = tag.tagSupport.templater.global;\n    const providersWithChanges = global.providers.filter(provider => !deepEqual(provider.instance, provider.clone));\n    // reset clones\n    providersWithChanges.forEach(provider => {\n        const appElement = tag.getAppElement();\n        handleProviderChanges(appElement, provider);\n        provider.clone = deepClone(provider.instance);\n    });\n}\nfunction handleProviderChanges(appElement, provider) {\n    const tagsWithProvider = getTagsWithProvider(appElement, provider);\n    tagsWithProvider.forEach(({ tag, renderCount, provider }) => {\n        if (tag.tagSupport.templater.global.deleted) {\n            return; // i was deleted after another tag processed\n        }\n        const notRendered = renderCount === tag.tagSupport.templater.global.renderCount;\n        if (notRendered) {\n            provider.clone = deepClone(provider.instance);\n            renderTagSupport(tag.tagSupport, false);\n        }\n    });\n}\nfunction getTagsWithProvider(tag, provider, memory = []) {\n    const global = tag.tagSupport.templater.global;\n    const compare = global.providers;\n    const hasProvider = compare.find(xProvider => xProvider.constructMethod === provider.constructMethod);\n    if (hasProvider) {\n        memory.push({\n            tag,\n            renderCount: global.renderCount,\n            provider: hasProvider,\n        });\n    }\n    tag.childTags.forEach(child => getTagsWithProvider(child, provider, memory));\n    return memory;\n}\n","import { deepClone } from '../deepFunctions';\nimport { setUse } from './setUse.function';\n// TODO: rename\nsetUse.memory.providerConfig = {\n    providers: [],\n    //currentTagSupport: undefined as TagSupport | undefined,\n    ownerTag: undefined,\n};\nfunction get(constructMethod) {\n    const config = setUse.memory.providerConfig;\n    const providers = config.providers;\n    return providers.find(provider => provider.constructMethod === constructMethod);\n}\nexport const providers = {\n    create: (constructMethod) => {\n        const existing = get(constructMethod);\n        if (existing) {\n            existing.clone = deepClone(existing.instance);\n            return existing.instance;\n        }\n        // Providers with provider requirements just need to use providers.create() and providers.inject()\n        const instance = constructMethod.constructor ? new constructMethod() : constructMethod();\n        const config = setUse.memory.providerConfig;\n        config.providers.push({\n            constructMethod,\n            instance,\n            clone: deepClone(instance)\n        });\n        return instance;\n    },\n    /**\n     * @template T\n     * @param {(new (...args: any[]) => T) | () => T} constructor\n     * @returns {T}\n     */\n    inject: (constructor) => {\n        const oldValue = get(constructor);\n        if (oldValue) {\n            return oldValue.instance;\n        }\n        const config = setUse.memory.providerConfig;\n        let owner = {\n            ownerTag: config.ownerTag\n        };\n        while (owner.ownerTag) {\n            const ownerProviders = owner.ownerTag.tagSupport.templater.global.providers;\n            const provider = ownerProviders.find(provider => {\n                if (provider.constructMethod === constructor) {\n                    return true;\n                }\n            });\n            if (provider) {\n                provider.clone = deepClone(provider.instance); // keep a copy of the latest before any change occur\n                config.providers.push(provider);\n                return provider.instance;\n            }\n            owner = owner.ownerTag; // cause reloop\n        }\n        const msg = `Could not inject provider: ${constructor.name} ${constructor}`;\n        console.warn(`${msg}. Available providers`, config.providers);\n        throw new Error(msg);\n    }\n};\nsetUse({\n    beforeRender: (tagSupport, ownerTag) => {\n        run(tagSupport, ownerTag);\n    },\n    beforeRedraw: (tagSupport, tag) => {\n        run(tagSupport, tag.ownerTag);\n    },\n    afterRender: (tagSupport) => {\n        const config = setUse.memory.providerConfig;\n        tagSupport.templater.global.providers = [...config.providers];\n        config.providers.length = 0;\n    }\n});\nfunction run(tagSupport, ownerTag) {\n    const config = setUse.memory.providerConfig;\n    // config.currentTagSupport = tagSupport\n    config.ownerTag = ownerTag;\n    if (tagSupport.templater.global.providers.length) {\n        config.providers.length = 0;\n        config.providers.push(...tagSupport.templater.global.providers);\n    }\n}\n","import { getStateValue } from './state.utils';\nimport { setUse } from './setUse.function';\n/** Used for variables that need to remain the same variable during render passes */\nexport function setProp(getSet) {\n    const config = setUse.memory.stateConfig;\n    const rearray = config.rearray;\n    const [propValue] = getSet(undefined);\n    getSet(propValue); // restore original value instead of undefined\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let watchValue = restate.watch;\n        let oldValue = getStateValue(restate);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSet,\n            lastValue: oldValue,\n            watch: restate.watch,\n        };\n        // has the prop value changed?\n        if (propValue != watchValue) {\n            push.watch = propValue;\n            oldValue = push.lastValue = propValue;\n        }\n        config.array.push(push);\n        getSet(oldValue);\n        return oldValue;\n    }\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSet,\n        lastValue: propValue,\n        watch: propValue,\n    };\n    config.array.push(push);\n    return propValue;\n}\n","const tagUse = [];\nexport function setUse(use) {\n    // must provide defaults\n    const useMe = {\n        beforeRender: use.beforeRender || (() => undefined),\n        beforeRedraw: use.beforeRedraw || (() => undefined),\n        afterRender: use.afterRender || (() => undefined),\n        beforeDestroy: use.beforeDestroy || (() => undefined),\n    };\n    setUse.tagUse.push(useMe);\n}\nsetUse.tagUse = tagUse;\nsetUse.memory = {};\n","import { setUse } from './setUse.function';\nimport { getStateValue } from './state.utils';\n/** Used for variables that need to remain the same variable during render passes */\nexport function state(defaultValue) {\n    const config = setUse.memory.stateConfig;\n    let getSetMethod;\n    const rearray = config.rearray;\n    const restate = rearray[config.array.length];\n    if (restate) {\n        let oldValue = getStateValue(restate);\n        getSetMethod = ((x) => [oldValue, oldValue = x]);\n        const push = {\n            get: () => getStateValue(push),\n            callback: getSetMethod,\n            lastValue: oldValue,\n            defaultValue: restate.defaultValue,\n        };\n        config.array.push(push);\n        return oldValue;\n    }\n    // State first time run\n    const defaultFn = defaultValue instanceof Function ? defaultValue : () => defaultValue;\n    let initValue = defaultFn();\n    getSetMethod = ((x) => [initValue, initValue = x]);\n    const push = {\n        get: () => getStateValue(push),\n        callback: getSetMethod,\n        lastValue: initValue,\n        defaultValue: initValue,\n    };\n    config.array.push(push);\n    return initValue;\n}\n","import { StateMismatchError } from '../errors';\nimport { setUse } from './setUse.function';\n// TODO: rename\nsetUse.memory.stateConfig = {\n    array: [], // state memory on the first render\n    // rearray: [] as StateConfigArray, // state memory to be used before the next render\n};\nconst beforeRender = (tagSupport) => initState(tagSupport);\nsetUse({\n    beforeRender,\n    beforeRedraw: beforeRender,\n    afterRender: (tagSupport) => {\n        const state = tagSupport.memory.state;\n        const config = setUse.memory.stateConfig;\n        const rearray = config.rearray;\n        if (rearray.length) {\n            if (rearray.length !== config.array.length) {\n                const message = `States lengths has changed ${rearray.length} !== ${config.array.length}. Typically occurs when a function is intended to be wrapped with a tag() call`;\n                const details = {\n                    oldStates: config.array,\n                    newStates: config.rearray,\n                    component: tagSupport.templater?.wrapper.original,\n                };\n                const error = new StateMismatchError(message, details);\n                console.warn(message, details);\n                throw error;\n            }\n        }\n        delete config.rearray; // clean up any previous runs\n        state.newest = config.array; // [...config.array]\n        state.newest.forEach(item => item.lastValue = getStateValue(item)); // set last values\n        config.array = [];\n    }\n});\nexport function getStateValue(\n// state: StateConfig,\nstate) {\n    const callback = state.callback;\n    if (!callback) {\n        return state.defaultValue;\n    }\n    const oldState = callback(StateEchoBack); // get value and set to undefined\n    const [oldValue] = oldState;\n    const [checkValue] = callback(oldValue); // set back to original value\n    if (checkValue !== StateEchoBack) {\n        const message = 'State property not used correctly. Second item in array is not setting value as expected.\\n\\n' +\n            'For \"let\" state use `let name = state(default)(x => [name, name = x])`\\n\\n' +\n            'For \"const\" state use `const name = state(default)()`\\n\\n' +\n            'Problem state:\\n' + (callback ? callback.toString() : JSON.stringify(state)) + '\\n';\n        console.error(message, { state, callback, oldState, oldValue, checkValue });\n        throw new Error(message);\n    }\n    // state.lastValue = oldValue\n    return oldValue;\n}\nexport class StateEchoBack {\n}\nfunction initState(tagSupport) {\n    const state = tagSupport.memory.state;\n    const config = setUse.memory.stateConfig;\n    // TODO: This guard may no longer be needed\n    if (config.rearray) {\n        const message = 'last state not cleared. Possibly in the middle of rendering one component and another is trying to render';\n        console.error(message, {\n            config,\n            component: tagSupport.templater?.wrapper.original,\n            wasInMiddleOf: config.tagSupport?.templater.wrapper.original,\n            state,\n            expectedClearArray: config.rearray,\n        });\n        throw new StateMismatchError(message, {\n            config,\n            component: tagSupport.templater?.wrapper.original,\n            state,\n            expectedClearArray: config.rearray,\n        });\n    }\n    // TODO: this maybe redundant and not needed\n    config.rearray = []; // .length = 0\n    if (state?.newest.length) {\n        state.newest.map(state => getStateValue(state));\n        config.rearray.push(...state.newest);\n    }\n    config.tagSupport = tagSupport;\n}\n","import { letState } from './letState.function';\n/**\n * When an item in watch array changes, callback function will be triggered. Does not trigger on initial watch setup.\n * @param currentValues T[]\n * @param callback WatchCallback\n * @returns T[]\n */\nexport function watch(currentValues, callback) {\n    let previousValues = letState(undefined)(x => [previousValues, previousValues = x]);\n    // First time running watch?\n    if (previousValues === undefined) {\n        // callback(currentValues, previousValues) // do not call during init\n        previousValues = currentValues;\n        return currentValues;\n    }\n    const allExact = currentValues.every((item, index) => item === previousValues[index]);\n    if (allExact) {\n        return currentValues;\n    }\n    callback(currentValues, previousValues);\n    previousValues.length = 0;\n    previousValues.push(...currentValues);\n    return currentValues;\n}\n","export class Subject {\n    value;\n    onSubscription;\n    methods = [];\n    isSubject = true;\n    subscribers = [];\n    subscribeWith;\n    // unsubcount = 0 // 🔬 testing\n    constructor(value, onSubscription) {\n        this.value = value;\n        this.onSubscription = onSubscription;\n    }\n    subscribe(callback) {\n        const subscription = getSubscription(this, callback);\n        // are we within a pipe?\n        const subscribeWith = this.subscribeWith;\n        if (subscribeWith) {\n            // are we in a pipe?\n            if (this.methods.length) {\n                const orgCallback = callback;\n                callback = (value) => {\n                    runPipedMethods(value, this.methods, lastValue => orgCallback(lastValue, subscription));\n                };\n            }\n            return subscribeWith(callback);\n        }\n        this.subscribers.push(subscription);\n        SubjectClass.globalSubs.push(subscription); // 🔬 testing\n        if (this.onSubscription) {\n            this.onSubscription(subscription);\n        }\n        return subscription;\n    }\n    set(value) {\n        this.value = value;\n        // Notify all subscribers with the new value\n        this.subscribers.forEach(sub => {\n            // (sub.callback as any).value = value\n            sub.callback(value, sub);\n        });\n    }\n    next = this.set;\n    toPromise() {\n        return new Promise((res, rej) => {\n            this.subscribe((x, subscription) => {\n                subscription.unsubscribe();\n                res(x);\n            });\n        });\n    }\n    // like toPromise but faster\n    toCallback(callback) {\n        this.subscribe((x, subscription) => {\n            subscription.unsubscribe();\n            callback(x);\n        });\n    }\n    pipe(...operations) {\n        const subject = new Subject();\n        subject.methods = operations;\n        subject.subscribeWith = (x) => this.subscribe(x);\n        return subject;\n    }\n}\nfunction removeSubFromArray(subscribers, callback) {\n    const index = subscribers.findIndex(sub => sub.callback === callback);\n    if (index !== -1) {\n        subscribers.splice(index, 1);\n    }\n}\nconst SubjectClass = Subject;\nSubjectClass.globalSubs = []; // 🔬 for testing\nSubjectClass.globalSubCount$ = new Subject(); // for ease of debugging\nSubjectClass.globalSubCount$.set(0);\nfunction getSubscription(subject, callback) {\n    const countSubject = SubjectClass.globalSubCount$;\n    SubjectClass.globalSubCount$.set(countSubject.value + 1);\n    const subscription = () => {\n        subscription.unsubscribe();\n    };\n    subscription.callback = callback;\n    subscription.subscriptions = [];\n    // Return a function to unsubscribe from the BehaviorSubject\n    subscription.unsubscribe = () => {\n        removeSubFromArray(subject.subscribers, callback); // each will be called when update comes in\n        removeSubFromArray(SubjectClass.globalSubs, callback); // 🔬 testing\n        SubjectClass.globalSubCount$.set(countSubject.value - 1);\n        // any double unsubscribes will be ignored\n        subscription.unsubscribe = () => subscription;\n        // unsubscribe from any combined subjects\n        subscription.subscriptions.forEach(subscription => subscription.unsubscribe());\n        return subscription;\n    };\n    subscription.add = (sub) => {\n        subscription.subscriptions.push(sub);\n        return subscription;\n    };\n    subscription.next = (value) => {\n        callback(value, subscription);\n    };\n    return subscription;\n}\nfunction runPipedMethods(value, methods, onComplete) {\n    const cloneMethods = [...methods];\n    const firstMethod = cloneMethods.shift();\n    const next = (newValue) => {\n        if (cloneMethods.length) {\n            return runPipedMethods(newValue, cloneMethods, onComplete);\n        }\n        onComplete(newValue);\n        // return newValue = next\n    };\n    let handler = next;\n    const setHandler = (x) => handler = x;\n    const pipeUtils = { setHandler, next };\n    const methodResponse = firstMethod(value, pipeUtils);\n    handler(methodResponse);\n}\n","import { Subject } from './Subject.class';\nexport class ValueSubject extends Subject {\n    value;\n    constructor(value) {\n        super(value);\n        this.value = value;\n    }\n    subscribe(callback) {\n        const subscription = super.subscribe(callback);\n        // Call the callback immediately with the current value\n        callback(this.value, subscription);\n        return subscription;\n    }\n}\n","import { Subject } from \"./Subject.class\";\nexport function combineLatest(subjects) {\n    const output = new Subject();\n    const subscribe = (callback) => {\n        const valuesSeen = [];\n        const values = [];\n        const setValue = (x, index) => {\n            valuesSeen[index] = true;\n            values[index] = x;\n            if (valuesSeen.length === subjects.length && valuesSeen.every(x => x)) {\n                callback(values, subscription);\n            }\n        };\n        const clones = [...subjects];\n        const firstSub = clones.shift();\n        const subscription = firstSub.subscribe(x => setValue(x, 0));\n        const subscriptions = clones.map((subject, index) => subject.subscribe(x => setValue(x, index + 1)));\n        subscription.subscriptions = subscriptions;\n        return subscription;\n    };\n    output.subscribeWith = subscribe;\n    return output;\n}\n","export * from './Subject.class';\nexport * from './ValueSubject';\nexport * from './combineLatest.function';\nexport * from './will.functions';\n","export function willCallback(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        });\n        callback(lastValue, utils.next);\n    });\n}\n/** .pipe( promise((x) => Promise.resolve(44)) ) */\nexport function willPromise(callback) {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        result.then(x => utils.next(x));\n    });\n}\n/** .pipe( willSubscribe((x) => new ValueSubject(44)) ) */\nexport const willSubscribe = (callback) => {\n    return ((lastValue, utils) => {\n        utils.setHandler(() => {\n            return undefined;\n        }); // do nothing on initial return\n        const result = callback(lastValue);\n        const subscription = result.subscribe(x => {\n            subscription.unsubscribe();\n            utils.next(x);\n        });\n    });\n};\n","import { isSubjectInstance, isTagArray, isTagInstance } from './isInstance';\nimport { setUse } from './state';\nimport { TemplaterResult } from './TemplaterResult.class';\nimport { runTagCallback } from './bindSubjectCallback.function';\nimport { deepClone } from './deepFunctions';\nimport { TagSupport } from './TagSupport.class';\nimport { alterProps } from './alterProps.function';\nimport { ValueSubject } from './subject/ValueSubject';\nexport const tags = [];\nlet tagCount = 0;\n/** Wraps a tag component in a state manager and always push children to last argument as an array */\n// export function tag<T>(a: T): T;\nexport function tag(tagComponent) {\n    const result = (function tagWrapper(props, children) {\n        const isPropTag = isTagInstance(props) || isTagArray(props);\n        if (isPropTag) {\n            children = props;\n            props = undefined;\n        }\n        const { childSubject, madeSubject } = kidsToTagArraySubject(children);\n        childSubject.isChildSubject = true;\n        const templater = new TemplaterResult(props, childSubject);\n        const innerTagWrap = getTagWrap(templater, madeSubject);\n        innerTagWrap.original = tagComponent;\n        templater.tagged = true;\n        templater.wrapper = innerTagWrap;\n        return templater;\n    }); // we override the function provided and pretend original is what's returned\n    updateResult(result, tagComponent);\n    // group tags together and have hmr pickup\n    updateComponent(tagComponent);\n    tags.push(tagComponent);\n    return result;\n}\nfunction kidsToTagArraySubject(children) {\n    if (isSubjectInstance(children)) {\n        return { childSubject: children, madeSubject: false };\n    }\n    const kidArray = children;\n    if (isTagArray(kidArray)) {\n        return { childSubject: new ValueSubject(children), madeSubject: true };\n    }\n    const kid = children;\n    if (kid) {\n        kid.memory.arrayValue = 0;\n        return { childSubject: new ValueSubject([kid]), madeSubject: true };\n    }\n    return {\n        childSubject: new ValueSubject([]),\n        madeSubject: true\n    };\n}\nfunction updateResult(result, tagComponent) {\n    result.isTag = true;\n    result.original = tagComponent;\n}\nfunction updateComponent(tagComponent) {\n    tagComponent.tags = tags;\n    tagComponent.setUse = setUse;\n    tagComponent.tagIndex = tagCount++; // needed for things like HMR\n}\n/** creates/returns a function that when called then calls the original component function */\nfunction getTagWrap(templater, madeSubject) {\n    const innerTagWrap = function (oldTagSetup, subject) {\n        const global = oldTagSetup.templater.global;\n        global.newestTemplater = templater;\n        ++global.renderCount;\n        templater.global = global;\n        const childSubject = templater.children;\n        const lastArray = global.oldest?.tagSupport.templater.children.lastArray;\n        if (lastArray) {\n            childSubject.lastArray = lastArray;\n        }\n        const originalFunction = innerTagWrap.original;\n        let props = templater.props;\n        let castedProps = alterProps(props, oldTagSetup.ownerTagSupport);\n        const clonedProps = deepClone(props); // castedProps\n        // CALL ORIGINAL COMPONENT FUNCTION\n        const tag = originalFunction(castedProps, childSubject);\n        tag.version = global.renderCount;\n        tag.tagSupport = new TagSupport(oldTagSetup.ownerTagSupport, templater, subject);\n        tag.tagSupport.propsConfig = {\n            latest: props, // castedProps\n            latestCloned: clonedProps,\n            clonedProps: clonedProps,\n            lastClonedKidValues: tag.tagSupport.propsConfig.lastClonedKidValues,\n        };\n        tag.tagSupport.memory = oldTagSetup.memory; // state handover\n        if (madeSubject) {\n            childSubject.value.forEach(kid => {\n                kid.values.forEach((value, index) => {\n                    if (!(value instanceof Function)) {\n                        return;\n                    }\n                    const valuesValue = kid.values[index];\n                    if (valuesValue.isChildOverride) {\n                        return; // already overwritten\n                    }\n                    // all functions need to report to me\n                    kid.values[index] = function (...args) {\n                        const ownerTag = tag.ownerTag;\n                        runTagCallback(value, // callback\n                        ownerTag, this, // bindTo\n                        args);\n                    };\n                    valuesValue.isChildOverride = true;\n                });\n            });\n        }\n        return tag;\n    };\n    return innerTagWrap;\n}\n","import { BaseTagSupport } from './TagSupport.class';\nimport { runAfterRender, runBeforeRender } from './tagRunner';\nimport { ValueSubject } from './subject/ValueSubject';\nconst appElements = [];\nexport function tagElement(app, // (...args: unknown[]) => TemplaterResult,\nelement, props) {\n    const appElmIndex = appElements.findIndex(appElm => appElm.element === element);\n    if (appElmIndex >= 0) {\n        appElements[appElmIndex].tag.destroy();\n        appElements.splice(appElmIndex, 1);\n        // an element already had an app on it\n        console.warn('Found and destroyed app element already rendered to element', { element });\n    }\n    // Create the app which returns [props, runOneTimeFunction]\n    const wrapper = app(props);\n    // have a function setup and call the tagWrapper with (props, {update, async, on})\n    const result = applyTagUpdater(wrapper);\n    const { tag } = result;\n    // TODO: is the below needed?\n    tag.appElement = element;\n    tag.tagSupport.templater.global.isApp = true;\n    const templateElm = document.createElement('template');\n    templateElm.setAttribute('id', 'app-tag-' + appElements.length);\n    templateElm.setAttribute('app-tag-detail', appElements.length.toString());\n    element.appendChild(templateElm);\n    tag.buildBeforeElement(templateElm);\n    wrapper.global.oldest = tag;\n    wrapper.global.newest = tag;\n    element.setUse = app.original.setUse;\n    appElements.push({ element, tag });\n    return { tag, tags: app.original.tags };\n}\nexport function applyTagUpdater(wrapper) {\n    const subject = new ValueSubject({});\n    const tagSupport = new BaseTagSupport(wrapper, subject);\n    wrapper.tagSupport = tagSupport;\n    runBeforeRender(tagSupport, undefined);\n    // Call the apps function for our tag templater\n    const tag = wrapper.wrapper(tagSupport, subject);\n    // wrapper.global.oldest = tag\n    // wrapper.global.newest = tag\n    runAfterRender(tagSupport, tag);\n    return { tag, tagSupport };\n}\n","// TODO: This should be more like `new TaggedJs().use({})`\nimport { setUse } from './state';\nimport { Subject } from './subject';\n// Emits event at the end of a tag being rendered. Use tagClosed$.toPromise() to render a tag after a current tag is done rendering\nexport const tagClosed$ = new Subject(undefined, subscription => {\n    if (!setUse.memory.stateConfig.rearray) {\n        subscription.next(); // we are not currently processing so process now\n    }\n});\n// Life cycle 1\nexport function runBeforeRender(tagSupport, tagOwner) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeRender(tagSupport, tagOwner));\n}\n// Life cycle 2\nexport function runAfterRender(tagSupport, tag) {\n    setUse.tagUse.forEach(tagUse => tagUse.afterRender(tagSupport, tag));\n    tagClosed$.next(tag);\n}\n// Life cycle 3\nexport function runBeforeRedraw(tagSupport, tag) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeRedraw(tagSupport, tag));\n}\n// Life cycle 4 - end of life\nexport function runBeforeDestroy(tagSupport, tag) {\n    setUse.tagUse.forEach(tagUse => tagUse.beforeDestroy(tagSupport, tag));\n}\n","// Function to update the value of x\nexport function updateBeforeTemplate(value, lastFirstChild) {\n    const parent = lastFirstChild.parentNode;\n    let castedValue = value;\n    // mimic React skipping to display EXCEPT for true does display on page\n    if ([undefined, false, null].includes(value)) { // || value === true\n        castedValue = '';\n    }\n    // Insert the new value (never use innerHTML here)\n    const textNode = document.createTextNode(castedValue); // never innerHTML\n    parent.insertBefore(textNode, lastFirstChild);\n    /* remove existing nodes */\n    parent.removeChild(lastFirstChild);\n    return textNode;\n}\n","import { hasTagSupportChanged } from './hasTagSupportChanged.function';\nimport { processSubjectComponent } from './processSubjectComponent.function';\nimport { destroyTagMemory } from './destroyTag.function';\nimport { renderTagSupport } from './renderTagSupport.function';\nimport { callbackPropOwner } from './alterProps.function';\nexport function updateExistingTagComponent(ownerTag, templater, subject, insertBefore) {\n    let existingTag = subject.tag;\n    const oldWrapper = existingTag.tagSupport.templater.wrapper;\n    const newWrapper = templater.wrapper;\n    let isSameTag = false;\n    if (oldWrapper && newWrapper) {\n        const oldFunction = oldWrapper.original;\n        const newFunction = newWrapper.original;\n        isSameTag = oldFunction === newFunction;\n    }\n    const oldTagSupport = existingTag.tagSupport;\n    const oldGlobal = oldTagSupport.templater.global;\n    // const placeholderElm = ownerTag.tagSupport.templater.global.placeholderElm\n    const placeholderElm = oldGlobal.placeholder;\n    if (!isSameTag) {\n        destroyTagMemory(oldTagSupport.templater.global.oldest, subject);\n        return processSubjectComponent(templater, subject, \n        // ??? - newly changed\n        insertBefore, // oldInsertBefore,\n        ownerTag, {\n            forceElement: false,\n            counts: { added: 0, removed: 0 },\n        });\n    }\n    else {\n        const newTagSupport = templater.tagSupport;\n        const hasChanged = hasTagSupportChanged(oldTagSupport, newTagSupport, templater);\n        if (!hasChanged) {\n            // if the new props are an object then implicitly since no change, the old props are an object\n            const newProps = templater.props;\n            if (newProps && typeof (newProps) === 'object') {\n                // const newestTag = oldTagSupport.templater.global.newest\n                // const oldProps = existingTag.tagSupport.propsConfig.latestCloned as Record<string,any> // newestTag.props as Record<string, any>\n                syncFunctionProps(templater, existingTag, ownerTag, newProps);\n            }\n            return existingTag; // its the same tag component\n        }\n    }\n    const oldestTag = templater.global.oldest; // oldTagSupport.oldest as Tag // existingTag\n    const previous = templater.global.newest;\n    const newTag = renderTagSupport(templater.tagSupport, false);\n    existingTag = subject.tag;\n    const newOldest = newTag.tagSupport.templater.global.oldest;\n    const hasOldest = newOldest ? true : false;\n    if (!hasOldest) {\n        return buildNewTag(newTag, \n        // ??? newly changed\n        insertBefore, // oldInsertBefore,\n        oldTagSupport, subject);\n    }\n    if (newOldest && templater.children.value.length) {\n        const oldKidsSub = newOldest.tagSupport.templater.children;\n        oldKidsSub.set(templater.children.value);\n    }\n    // detect if both the function is the same and the return is the same\n    const isLikeTag = isSameTag && previous.isLikeTag(newTag);\n    let oldest = oldTagSupport.templater.global.oldest;\n    if (isLikeTag) {\n        subject.tag = newTag;\n        oldestTag.updateByTag(newTag); // the oldest tag has element references\n        return newTag;\n    }\n    else {\n        // Although function looked the same it returned a different html result\n        if (isSameTag && existingTag) {\n            destroyTagMemory(existingTag, subject);\n            newTag.tagSupport.templater.global.context = {}; // do not share previous outputs\n        }\n        oldest = undefined;\n    }\n    if (!oldest) {\n        buildNewTag(newTag, oldTagSupport.templater.global.insertBefore, oldTagSupport, subject);\n    }\n    oldTagSupport.templater.global.newest = newTag;\n    return newTag;\n}\nfunction checkStateChanged(state) {\n    return !state.newest.every(state => {\n        const lastValue = state.lastValue;\n        const nowValue = state.get();\n        const matched = lastValue === nowValue;\n        if (matched) {\n            return true;\n        }\n        return false;\n    });\n}\nfunction buildNewTag(newTag, oldInsertBefore, oldTagSupport, subject) {\n    newTag.buildBeforeElement(oldInsertBefore, {\n        forceElement: true,\n        counts: { added: 0, removed: 0 },\n    });\n    newTag.tagSupport.templater.global.oldest = newTag;\n    newTag.tagSupport.templater.global.newest = newTag;\n    oldTagSupport.templater.global.oldest = newTag;\n    oldTagSupport.templater.global.newest = newTag;\n    subject.tag = newTag;\n    return newTag;\n}\nfunction syncFunctionProps(templater, existingTag, ownerTag, newProps) {\n    existingTag = existingTag.tagSupport.templater.global.newest;\n    // const templater = existingTag.tagSupport.templater\n    const priorProps = existingTag.tagSupport.propsConfig.latestCloned;\n    const oldLatest = ownerTag.tagSupport.templater.global.newest;\n    const ownerSupport = oldLatest.tagSupport;\n    Object.entries(priorProps).forEach(([name, value]) => {\n        if (!(value instanceof Function)) {\n            return;\n        }\n        const newOriginal = value.original;\n        // TODO: The code below maybe irrelevant\n        const newCallback = newProps[name];\n        const original = newCallback.original;\n        if (original) {\n            return; // already previously converted\n        }\n        // Currently, call self but over parent state changes, I may need to call a newer parent tag owner\n        priorProps[name].toCall = (...args) => {\n            return callbackPropOwner(newCallback, // value, // newOriginal,\n            args, ownerSupport);\n        };\n        return;\n    });\n}\n","import { TagSupport } from './TagSupport.class';\nimport { isSubjectInstance, isTagArray, isTagComponent, isTagInstance } from './isInstance';\nimport { processTagArray } from './processTagArray';\nimport { updateExistingTagComponent } from './updateExistingTagComponent.function';\nimport { processRegularValue } from './processRegularValue.function';\nimport { checkDestroyPrevious } from './checkDestroyPrevious.function';\nimport { processSubjectComponent } from './processSubjectComponent.function';\nimport { isLikeTags } from './isLikeTags.function';\nimport { bindSubjectCallback } from './bindSubjectCallback.function';\nimport { applyFakeTemplater, processTag } from './processTag.function';\nexport function updateExistingValue(subject, value, ownerTag, insertBefore) {\n    const subjectTag = subject;\n    const isComponent = isTagComponent(value);\n    checkDestroyPrevious(subject, value, insertBefore);\n    // handle already seen tag components\n    if (isComponent) {\n        const templater = value;\n        // When was something before component\n        if (!subjectTag.tag) {\n            processSubjectComponent(templater, subjectTag, insertBefore, // oldInsertBefore as InsertBefore,\n            ownerTag, {\n                forceElement: true,\n                counts: { added: 0, removed: 0 },\n            });\n            return subjectTag;\n        }\n        templater.tagSupport = new TagSupport(\n        // subjectTag.tag.tagSupport.ownerTagSupport,\n        ownerTag.tagSupport, templater, subjectTag);\n        updateExistingTagComponent(ownerTag, templater, // latest value\n        subjectTag, insertBefore);\n        return subjectTag;\n    }\n    // was component but no longer\n    const tag = subjectTag.tag;\n    if (tag) {\n        handleStillTag(tag, subject, value, ownerTag);\n        return subjectTag;\n    }\n    // its another tag array\n    if (isTagArray(value)) {\n        processTagArray(subject, value, insertBefore, // oldInsertBefore as InsertBefore,\n        ownerTag, { counts: {\n                added: 0,\n                removed: 0,\n            } });\n        return subject;\n    }\n    // now its a function\n    if (value instanceof Function) {\n        // const newSubject = getSubjectFunction(value, ownerTag)\n        const bound = bindSubjectCallback(value, ownerTag);\n        subject.set(bound);\n        return subject;\n    }\n    if (isTagInstance(value)) {\n        processTag(value, subjectTag, insertBefore, ownerTag);\n        return subjectTag;\n    }\n    // we have been given a subject\n    if (isSubjectInstance(value)) {\n        return value;\n    }\n    // This will cause all other values to render\n    processRegularValue(value, subject, \n    // ??? - changed to insertBefore for tag switching with template removal\n    insertBefore // oldInsertBefore as InsertBefore,\n    );\n    return subjectTag;\n}\nfunction handleStillTag(existingTag, subject, value, ownerTag) {\n    // TODO: We shouldn't need both of these\n    const isSameTag = value && isLikeTags(existingTag, value);\n    const isSameTag2 = value && value.getTemplate && existingTag.isLikeTag(value);\n    const tag = value;\n    if (!tag.tagSupport) {\n        applyFakeTemplater(tag, ownerTag, subject);\n    }\n    if (isSameTag) {\n        existingTag.updateByTag(tag);\n        return;\n    }\n    if (isSameTag || isSameTag2) {\n        const subjectTag = subject;\n        const global = existingTag.tagSupport.templater.global;\n        const insertBefore = global.insertBefore;\n        return processTag(value, subjectTag, insertBefore, ownerTag);\n    }\n    return processRegularValue(value, subject, subject.insertBefore);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { html, letState, tag } from 'taggedjs';\nimport { dump } from 'taggedjs-dump';\nimport { stripeList } from './sampleData';\nexport { tagElement } from 'taggedjs';\nexport const Dump = tag(() => {\n    let userJsonString = letState('')(x => [userJsonString, userJsonString = x]);\n    // const userJson = JSON.parse(userJsonString)\n    let badEval = false;\n    let userJson;\n    try {\n        userJson = sandboxEval(userJsonString, {});\n        userJsonString = JSON.stringify(userJson, null, 2);\n    }\n    catch (err) {\n        badEval = true;\n        try {\n            JSON.parse(userJsonString);\n        }\n        catch (err) {\n            userJson = Object.getOwnPropertyNames(err).reduce((a, key) => (a[key] = err[key]) && a || a, {});\n        }\n    }\n    const change = (event) => {\n        userJsonString = event.target.value;\n    };\n    return html `\n    <h3>🔭 TaggedJs Dump demo page</h3>\n    \n    <p>Use the textarea below to cast JSON into an interactive display</p>\n\n    ${badEval && html `\n      <div style=\"color:white;background-color:red;padding:.5em;\"\n      >Input data appears to be invalid</div>\n    `}\n    \n    <div style=\"display:flex;flex-wrap:wrap;align-item:center;justify-content: center;gap:.5em;padding:.5em;\">\n      <textarea wrap=\"off\" placeholder=\"paste json here\"\n        onchange=${change}\n        style=\"min-width:300px;min-height:400px;flex:1\"\n      >${userJson === \"\" ? \"\" : userJsonString}</textarea>\n\n      ${userJson === \"\" ? \"\" : html `\n        <div style=\"flex:1;min-width:110px;width:100%;max-width:900px;background-color:rgba(255,255,255,.5);min-width:300px\">\n          ${dump({\n        value: userJson\n    })}\n        </div>\n      `}\n    </div>\n\n    <br />\n\n    <h3>Sample Dumps</h3>\n    <hr />\n\n    <div style=\"display:flex;flex-wrap:wrap;align-item:center;justify-content: center;gap:1em;\">      \n      <div style=\"max-width:900px\">\n        ${dump({\n        value: {\n            test: {\n                anotherOne: 22\n            },\n            arrayTest: [{\n                    name: 'something',\n                    location: { street: '4361' },\n                }, {\n                    name: 'in this',\n                    location: { street: '2235' },\n                }, {\n                    name: 'world',\n                    location: { street: '4785' },\n                }]\n        }\n    })}\n        <hr />\n        ${dump({\n        value: stripeList\n    })}\n      </div>\n    </div>\n  `;\n});\n// execute script in private context\nfunction sandboxEval(src, ctx) {\n    if (!src) {\n        return src;\n    }\n    ctx = new Proxy(ctx, { has: () => true });\n    let func = (new Function(\"with(this) { return (\" + src + \")}\"));\n    return func.call(ctx);\n}\n"],"names":[],"sourceRoot":""}